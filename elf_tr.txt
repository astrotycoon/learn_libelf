		 Notes on the Flat-Text Transcription

The content of this transcription differs from the content of the
original document in the following ways.

1. Page breaks and pagination have been omitted.
2. As a result of the above, the page numbers have been left out of
   the table of contents, and the index has been omitted entirely.
   (Unlike a Postscript document, a text file can be searched.)
3. The contents of the title page and the footer text has been placed
   at the beginning.
4. The lines and boxes in the original figures and tables have been
   adapted.
5. Differing fonts have, of necessity, been elided. For the most part,
   the context is sufficient to understand the meaning. In a few
   places, however, the original document used italics to implicitly
   indicate that the text stood for a variable string. In these cases,
   I have used <angle brackets> around the text to indicate this.
   There are no occurrences of angle brackets in the original.
6. The original contains three errors which are not immediately
   obvious as such upon a casual reading, but which can be
   unambiguously identified as such and the proper contents
   determined. I have taken the liberty to correct these errors. Their
   locations are marked in the text by a {*}. Any other (seeming)
   errors I have let stand.

Any other differences between the contents of this file and the
original are my responsibility. Direct notices of such errors to
breadbox@muppetlabs.com.

Brian Raiter
[Last edited Fri Jul 23 1999]

   ________________________________________________________________


		 EXECUTABLE AND LINKABLE FORMAT (ELF)

	     Portable Formats Specification, Version 1.1
		    Tool Interface Standards (TIS)

   ________________________________________________________________


   =========================== Contents ===========================


   PREFACE
1. OBJECT FILES
   Introduction
   ELF Header
   Sections
   String Table
   Symbol Table
   Relocation
2. PROGRAM LOADING AND DYNAMIC LINKING
   Introduction
   Program Header
   Program Loading
   Dynamic Linking
3. C LIBRARY
   C Library

   ________________________________________________________________


			       PREFACE

   ________________________________________________________________


		  ELF: Executable and Linking Format

The Executable and Linking Format was originally developed and
published by UNIX System Laboratories (USL) as part of the Application
Binary Interface (ABI). The Tool Interface Standards committee (TIS)
has selected the evolving ELF standard as a portable object file
format that works on 32-bit Intel Architecture environments for a
variety of operating systems.

The ELF standard is intended to streamline software development by
providing developers with a set of binary interface definitions that
extend across multiple operating environments. This should reduce the
number of different interface implementations, thereby reducing the
need for recoding and recompiling code.


			 About This Document

This document is intended for developers who are creating object or
executable files on various 32-bit environment operating systems. It
is divided into the following three parts:

* Part 1, ``Object Files'' describes the ELF object file format for
  the three main types of object files.
* Part 2, ``Program Loading and Dynamic Linking'' describes the object
  file information and system actions that create running programs.
* Part 3, ``C Library'' lists the symbols contained in libsys, the
  standard ANSI C and libc routines, and the global data symbols
  required by the libc routines.

NOTE: References to X86 architecture have been changed to Intel
Architecture.

   ________________________________________________________________


			   1. OBJECT FILES

   ________________________________________________________________


   ========================= Introduction =========================


Part 1 describes the iABI object file format, called ELF (Executable
and Linking Format). There are three main types of object files.

* A relocatable file holds code and data suitable for linking with
  other object files to create an executable or a shared object file.
	可重定位文件。 可重定位文件中包含链接器需要的代码和数据信息，链接器根据
	这些信息将多个可重定位文件通过链接过程生成可执行文件或者生成共享库。
* An executable file holds a program suitable for execution; the file
  specifies how exec(BA_OS) creates a program's process image.
	可执行文件。顾名思义，可执行文件中包含最后需要执行的程序。它的信息用于指导操作系统如何生成最后的进程映像。
* A shared object file holds code and data suitable for linking in two
  contexts. First, the link editor [see ld(SD_CMD)] may process it
  with other relocatable and shared object files to create another
  object file. Second, the dynamic linker combines it with an
  executable file and other shared objects to create a process image.
	共享库。共享库中的代码和数据主要有两个用途。第一，静态链接器（例如GNU ld）利用共享库和可重定位文件
	生成最终的目标文件（可以是可执行文件，也可以是生成新的共享库）。第二，动态链接器利用共享库和可执行文件来生成最终的进程映像。

Created by the assembler and link editor, object files are binary
representations of programs intended to execute directly on a
processor. Programs that require other abstract machines, such as
shell scripts, are excluded.
经过汇编器和链接器一些列处理后的目标文件就是程序最终的二进制表现形式，这些二进制是处理器可以识别的指令序列。
注意，某些程序的执行必须通过解释器的帮助才能执行（例如大家熟知的shell脚本），它们不在我们的讨论范畴。

After the introductory material, Part 1 focuses on the file format and
how it pertains to building programs. Part 2 also describes parts of
the object file, concentrating on the information necessary to execute
a program.
接下来分两部分讨论ELF文件。第一部分，介绍ELF的文件格式，着重介绍有利于帮助生成最终可执行文件的信息。
第二部分，同样是介绍ELF的文件格式，不过着重于程序最终执行的信息。


			     File Format

Object files participate in program linking (building a program) and
program execution (running a program). For convenience and efficiency,
the object file format provides parallel views of a file's contents,
reflecting the differing needs of these activities. Figure 1-1 shows
an object file's organization.
在生成最终程序的链接阶段和程序最终在操作系统中运行这两个过程中都是需要目标文件参与其中的。因此为了方便与高效，
目标文件根据这两个过程分别包含不同的信息，以适应每个过程的需要。
图1-1是从两个不同的视角来看目标文件的内容，一个是链接时视角，一个是运行时视角。

+ Figure 1-1: Object File Format

  Linking View                      Execution View
  ============                      ==============
  ELF header                        ELF header
  Program header table (optional)   Program header table
  Section 1                         Segment 1
  ...                               Segment 2
  Section n                         ...
  Section header table              Section header table (optional)

An ELF header resides at the beginning and holds a ``road map''
describing the file's organization. Sections hold the bulk of object
file information for the linking view: instructions, data, symbol
table, relocation information, and so on. Descriptions of special
sections appear later in Part 1. Part 2 discusses segments and the
program execution view of the file.
ELF头部结构（ELF header）在文件的开头，它就像一个“总览图”一样，描述整个文件的组织结构。
节（sections）中所包含的信息主要用于程序的链接，这些信息包括：程序指令，程序数据，符号表，重定位信息等等。
在本文档的后续部分，我们先着重描述节的信息结构，介绍各个比较重要的节的作用。
然后介绍程序运行时需要的段（segments）信息。


A program header table, if present, tells the system how to create a
process image. Files used to build a process image (execute a program)
must have a program header table; relocatable files do not need one. A
section header table contains information describing the file's
sections. Every section has an entry in the table; each entry gives
information such as the section name, the section size, etc. Files
used during linking must have a section header table; other object
files may or may not have one.
程序头表（program header table）是用来告诉操作系统如何生成一个进程映像。
一个可执行文件必须包含一个程序头表，而可重定位文件则是不需要，因为可重定位文件用于程序链接，不需要运行。
节头表（section header table）中的信息用于描述文件中的所有节。节头表由一个一个的表项组成，一个表项对应
文件中一个节，用来描述该节的诸多属性，属性包括节名（section name），节的大小（section size）等等。用于
链接阶段的可重定位文件和共享库文件中必须包含有节头表。

NOTE: Although the figure shows the program header table immediately
after the ELF header, and the section header table following the
sections, actual files may differ. Moreover, sections and segments
have no specified order. Only the ELF header has a fixed position in
the file.
警告：尽管从图1-1中看到程序头表直接在ELF头部结构的后边，而节头表在所有节的后边，但实际的文件并不需要遵守这个布局。
此外，节和段的布局并没有一个规定的顺序，只有ELF文件头部必须是在文件的开始处。


			 Data Representation 数据表示

As described here, the object file format supports various processors
with 8-bit bytes and 32-bit architectures. Nevertheless, it is
intended to be extensible to larger (or smaller) architectures.
Object files therefore represent some control data with a
machine-independent format, making it possible to identify object
files and interpret their contents in a common way. Remaining data in
an object file use the encoding of the target processor, regardless of
the machine on which the file was created.
理论上，ELF文件格式应该支持所有的处理器和平台。因此，ELF文件中肯定有一些是与机器无关的控制信息，
识别这些控制信息的方法在所有平台上都是相同的。 而剩余的文件内容则是处理器相关的，例如大小端格式，这些信息是目标平台相关的，与
生成ELF文件的平台无关（例如嵌入式开发中，会在X86平台上利用交叉编译环境生成ARM平台的ELF文件）。

+ Figure 1-2: 32-Bit Data Types

  Name           Size Alignment   Purpose
  ====           ==== =========   =======
  Elf32_Addr      4       4       Unsigned program address
  Elf32_Half      2       2       Unsigned medium integer
  Elf32_Off       4       4       Unsigned file offset
  Elf32_Sword     4       4       Signed large integer
  Elf32_Word      4       4       Unsigned large integer
  unsigned char   1       1       Unsigned small integer

All data structures that the object file format defines follow the
``natural'' size and alignment guidelines for the relevant class. If
necessary, data structures contain explicit padding to ensure 4-byte
alignment for 4-byte objects, to force structure sizes to a multiple
of 4, etc. Data also have suitable alignment from the beginning of the
file. Thus, for example, a structure containing an Elf32_Addr member
will be aligned on a 4-byte boundary within the file.
所有的结构都遵循目标平台的对齐要求。因此有时会显示地填充空白空间来促使4字节
大小的成员4字节对齐，8字节大小的成员8字节对齐，这样才能保证最终的结构大小是
4字节或者8字节的整数倍。此外，整个结构体在文件中也应该适当的对齐。例如，如果
结构体中包含有Elf32_Addr的数据成员，那么这个结构体在文件中应该4字节对齐。

For portability reasons, ELF uses no bit-fields.
考虑到可移植性，ELF数据结构中没有使用位域（bit-fields）。


   ========================== ELF Header ==========================
							  ELF文件头

Some object file control structures can grow, because the ELF header
contains their actual sizes. If the object file format changes, a
program may encounter control structures that are larger or smaller
than expected. Programs might therefore ignore``extra'' information.
The treatment of ``missing'' information depends on context and will
be specified when and if extensions are defined.

+ Figure 1-3: ELF Header
  #define EI_NIDENT       16

  typedef struct {
      unsigned char       e_ident[EI_NIDENT];	/* magic number及其他信息 */
      Elf32_Half          e_type;				/* ELF文件类型 */
      Elf32_Half          e_machine;			/* 目标机器型号 */
      Elf32_Word          e_version;			/* 版本号 */
      Elf32_Addr          e_entry;				/* 程序入口虚拟地址 */
      Elf32_Off           e_phoff;				/* 程序头表在文件中的偏移量 */
      Elf32_Off           e_shoff;				/* 节头表在文件中的偏移量 */
      Elf32_Word          e_flags;				/* 处理器标志 */
      Elf32_Half          e_ehsize;				/* 本ELF文件头大小 -- 52字节 */
      Elf32_Half          e_phentsize;			/* 程序头表表项大小 */
      Elf32_Half          e_phnum;				/* 程序头表表项个数 */
      Elf32_Half          e_shentsize;			/* 节头表表项大小 */
      Elf32_Half          e_shnum;				/* 节头表表项个数 */
      Elf32_Half          e_shstrndx;			/* 节名字符串表的节头表索引值 */
  } Elf32_Ehdr;

* e_ident
  The initial bytes mark the file as an object file and provide
  machine-independent data with which to decode and interpret the
  file's contents. Complete descriptions appear below, in ``ELF
  Identification.''

* e_type

  This member identifies the object file type.

             	Name        Value  Meaning
               	====        =====  =======
             	ET_NONE         0  No file type
               	ET_REL          1  Relocatable file
               	ET_EXEC         2  Executable file
               	ET_DYN          3  Shared object file
	       		ET_CORE         4  Core file
	       		ET_LOPROC  0xff00  Processor-specific
	       		ET_HIPROC  0xffff  Processor-specific

  Although the core file contents are unspecified, type ET_CORE is
  reserved to mark the file. Values from ET_LOPROC through ET_HIPROC
  (inclusive) are reserved for processor-specific semantics. Other
  values are reserved and will be assigned to new object file types as
  necessary.

* e_machine

  This member's value specifies the required architecture for an
  individual file.

                    Name      Value  Meaning
	            	====      =====  =======
                    EM_NONE       0  No machine
		    		EM_M32        1  AT&T WE 32100
                    EM_SPARC      2  SPARC
                    EM_386        3  Intel 80386
                    EM_68K        4  Motorola 68000
                    EM_88K        5  Motorola 88000
                    EM_860        7  Intel 80860
                    EM_MIPS       8  MIPS RS3000

  Other values are reserved and will be assigned to new machines as
  necessary. Processor-specific ELF names use the machine name to
  distinguish them. For example, the flags mentioned below use the
  prefix EF_; a flag named WIDGET for the EM_XYZ machine would be
  called EF_XYZ_WIDGET.

* e_version

  This member identifies the object file version.

                 Name         Value  Meaning
                 ====         =====  =======
                 EV_NONE          0  Invalid version
		 		 EV_CURRENT       1  Current version

  The value 1 signifies the original file format; extensions will
  create new versions with higher numbers. The value of EV_CURRENT,
  though given as 1 above, will change as necessary to reflect the
  current version number.

* e_entry

  This member gives the virtual address to which the system first
  transfers control, thus starting the process. If the file has no
  associated entry point, this member holds zero.
  成员e_entry的值给出的是系统将控制权交给程序时的虚拟地址，进程才得以启动。

* e_phoff

  This member holds the program header table's file offset in bytes.
  If the file has no program header table, this member holds zero.

* e_shoff

  This member holds the section header table's file offset in bytes.
  If the file has no section header table, this member holds zero.

* e_flags
  This member holds processor-specific flags associated with the file.
  Flag names take the form EF_<machine>_<flag>. See ``Machine
  Information'' for flag definitions.

* e_ehsize

  This member holds the ELF header's size in bytes.

* e_phentsize

  This member holds the size in bytes of one entry in the file's
  program header table; all entries are the same size.

* e_phnum

  This member holds the number of entries in the program header
  table. Thus the product of e_phentsize and e_phnum gives the table's
  size in bytes. If a file has no program header table, e_phnum holds
  the value zero.

* e_shentsize

  This member holds a section header's size in bytes. A section header
  is one entry in the section header table; all entries are the same
  size.

* e_shnum

  This member holds the number of entries in the section header table.
  Thus the product of e_shentsize and e_shnum gives the section header
  table's size in bytes. If a file has no section header table,
  e_shnum holds the value zero.

* e_shstrndx

  This member holds the section header table index of the entry
  associated with the section name string table. If the file has no
  section name string table, this member holds the value SHN_UNDEF.
  See ``Sections'' and ``String Table'' below for more information.


			  ELF Identification

As mentioned above, ELF provides an object file framework to support
multiple processors, multiple data encodings, and multiple classes of
machines. To support this object file family, the initial bytes of the
file specify how to interpret the file, independent of the processor
on which the inquiry is made and independent of the file's remaining
contents.

The initial bytes of an ELF header (and an object file) correspond to
the e_ident member.

+ Figure 1-4: e_ident[] Identification Indexes

  Name           Value  Purpose
  ====           =====  =======
  EI_MAG0	     0  File identification
  EI_MAG1	     1  File identification
  EI_MAG2	     2  File identification
  EI_MAG3	     3  File identification
  EI_CLASS	     4  File class
  EI_DATA	     5  Data encoding
  EI_VERSION	 6  File version
  EI_PAD	     7  Start of padding bytes
  EI_NIDENT	    16  Size of e_ident[]

These indexes access bytes that hold the following values.

* EI_MAG0 to EI_MAG3

  A file's first 4 bytes hold a ``magic number,'' identifying the file
  as an ELF object file.

          		Name       Value  Position
              	====       =====  ========
		  		ELFMAG0    0x7f   e_ident[EI_MAG0]
               	ELFMAG1    'E'    e_ident[EI_MAG1]
               	ELFMAG2    'L'    e_ident[EI_MAG2]
               	ELFMAG3    'F'    e_ident[EI_MAG3]

* EI_CLASS

  The next byte, e_ident[EI_CLASS], identifies the file's class, or
  capacity.

              	Name           Value  Meaning
               	====           =====  =======
               	ELFCLASSNONE       0  Invalid class
               	ELFCLASS32         1  32-bit objects
		 		ELFCLASS64         2  64-bit objects

  The file format is designed to be portable among machines of various
  sizes, without imposing the sizes of the largest machine on the
  smallest. Class ELFCLASS32 supports machines with files and virtual
  address spaces up to 4 gigabytes; it uses the basic types defined
  above.

  Class ELFCLASS64 is reserved for 64-bit architectures. Its
  appearance here shows how the object file may change, but the 64-bit
  format is otherwise unspecified. Other classes will be defined as
  necessary, with different basic types and sizes for object file
  data.

* EI_DATA

  Byte e_ident[EI_DATA] specifies the data encoding of the
  processor-specific data in the object file. The following encodings
  are currently defined.

            	Name           Value  Meaning
            	====           =====  =======
	     		ELFDATANONE        0  Invalid data encoding
            	ELFDATA2LSB        1  See below
            	ELFDATA2MSB        2  See below

  More information on these encodings appears below. Other values are
  reserved and will be assigned to new encodings as necessary.

* EI_VERSION

  Byte e_ident[EI_VERSION] specifies the ELF header version number.
  Currently this, value must be EV_CURRENT, as explained above for
  e_version.

* EI_PAD

  This value marks the beginning of the unused bytes in e_ident. These
  bytes are reserved and set to zero; programs that read object files
  should ignore them.  The value of EI_PAD will change in the future
  if currently unused bytes are given meanings.

A file's data encoding specifies how to interpret the basic objects in
a file. As described above, class ELFCLASS32 files use objects that
occupy 1, 2, and 4 bytes. Under the defined encodings, objects are
represented as shown below. Byte numbers appear in the upper left
corners.

Encoding ELFDATA2LSB specifies 2's complement values, with the least
significant byte occupying the lowest address.

+ Figure 1-5: Data Encoding ELFDATA2LSB

       	        	0------+
      	  0x01   	|  01  |
       	        	+------+
       	        	0------1------+
    	0x0102  	|  02  |  01  |
       	        	+------+------+
       	        	0------1------2------3------+
  	0x01020304   	|  04  |  03  |  02  |  01  |
         	      	+------+------+------+------+

ELFDATA2MSB specifies 2's complement values, with the most significant
byte occupying the lowest address.

+ Figure 1-6: Data Encoding ELFDATA2MSB

      	        	0------+
      	  0x01 		|  01  |
               		+------+
               		0------1------+
    	0x0102   	|  01  |  02  |
               		+------+------+
               		0------1------2------3------+
  	0x01020304   	|  01  |  02  |  03  |  04  |
               		+------+------+------+------+



			 Machine Information

For file identification in e_ident, the 32-bit Intel Architecture
requires the following values.

+ Figure 1-7: 32-bit Intel Architecture Identification, e_ident 

  Position           Value
  ========           =====
  e_ident[EI_CLASS]  ELFCLASS32
  e_ident[EI_DATA]   ELFDATA2LSB

Processor identification resides in the ELF header's e_machine member
and must have the value EM_386.

The ELF header's e_flags member holds bit flags associated with the
file. The 32-bit Intel Architecture defines no flags; so this member
contains zero.


   =========================== Sections ===========================
								  节
An object file's section header table lets one locate all the file's
sections. The section header table is an array of Elf32_Shdr or Elf64_Shdr
structures as described below. A section header table index is a
subscript into this array. The ELF header's e_shoff member gives the
byte offset from the beginning of the file to the section header
table; e_shnum tells how many entries the section header table
contains; e_shentsize gives the size in bytes of each entry.
通过目标文件中的节头表，我们就可以轻松地定位文件中所有的节。节头表是若干结构Elf32_Shdr或者结构Elf64_Shdr
组成的数组。节头表索引是用来定位节头表的表项的。ELF文件头中的e_shoff代表是节头表在文件中的偏移值；e_shnum代表的
是节头表的表项个数；e_shentsize代表的是节头表的表项大小。

If the number of sections is greater than or equal to SHN_LORESERVE (0xff00), e_shnum has 
the value SHN_UNDEF (0) and the actual number of section header table entries is contained 
in the sh_size field of the section header at index 0 (otherwise, the sh_size member of the initial entry contains 0).
如果节头表的表项个数大于或者等于SHN_LORESERVE（0xff00）的话，成员e_shnum的值为SHN_UNDEF（0），那么真正的节头表表项个数
存储在节头表中第一表项（节头表索引值为0）中的成员sh_size里（否则，一般情况下，第一表项的成员sh_size的值为0）。

Some section header table indexes are reserved in contexts where index size is restricted, 
for example, the st_shndx member of a symbol table entry and the e_shnum and e_shstrndx members of the ELF header. 
In such contexts, the reserved values do not represent actual sections in the object file. 
Also in such contexts, an escape value indicates that the actual section index is to be found elsewhere, in a larger field.
需要注意的是，有一些特殊的节头表索引值是预留的，这些预留值可能会被符号表表项成员st_shndx和ELF文件头成员e_shnum和e_shstrndx使用到。
在这种情况下，这些预留值的意义并不是说明在目标文件中真实存在这些索引值的节，而是有其特殊的含义。
同样的，在这种情况下，一个 逸出值（escape value） 表明真实的节头表索引值存储在别处（一个大小足够能容纳真实节头表索引值的地方）。
 name			escape value					elsewhere
==========		==============				   ==========
e_shnum 	->   SHN_UNDEF 		 ======> 		sh_size
e_shstrndx	->   SHN_XINDEX		 ======>		sh_link

 name			reserve value 					meaning	
==========      ==============				   ==========	
st_shndx	->   SHN_UNDEF		 ======> 	    该符号是个未定义符号
st_shndx	->   SHN_ABS	     ======>		该符号是文件符号（STT_FILE）
st_shndx	->   SHN_COMMON		 ======>		该符号是公用块数据		

(OLD)Some section header table indexes are reserved; an object file will
not have sections for these special indexes.
+ Figure 1-8: Special Section Indexes
  Name             Value
  ====             =====
  SHN_UNDEF            0
  SHN_LORESERVE   0xff00
  SHN_LOPROC      0xff00
  SHN_HIPROC      0xff1f
  SHN_LOOS		  0xff20
  SHN_HIOS		  0xff3f
  SHN_ABS         0xfff1
  SHN_COMMON      0xfff2
  SHN_XINDEX	  0Xffff
  SHN_HIRESERVE   0xffff

* SHN_UNDEF
  This value marks an undefined, missing, irrelevant, or otherwise
  meaningless section reference. For example, a symbol ``defined''
  relative to section number SHN_UNDEF is an undefined symbol.
  当节头表索引值为SHN_UNDEF时，表明的是一个未定义、不存在的节头表索引。
  例如，当一个符号表表项的成员st_shndx值为SHN_UNDEF时，代表该符号是个未定义符号；
  当e_shnum的值是SHN_UNDEF是，表明真实的节头表表项个数（也就是目标文件中节的总个数）存储在第一个（即节头表索引值为0）
  节头表表项的成员sh_size中；

NOTE: Although index 0 is reserved as the undefined value, the section
header table contains an entry for index 0. That is, if the e_shnum
member of the ELF header says a file has 6 entries in the section
header table, they have the indexes 0 through 5. The contents of the
initial entry are specified later in this section.
注意：尽管索引值SHN_UNDEF（0）是个预留值，但是节头表的索引值依然是从0开始的。
如果ELF文件头成员e_shnum的值为6，说明该目标文件中的节头表有6个表项（即目标文件中有6个节），
它们的索引值为0 ~ 5。

* SHN_LORESERVE
  This value specifies the lower bound of the range of reserved
  indexes.

* SHN_LOPROC through SHN_HIPROC
  Values in this inclusive range are reserved for processor-specific
  semantics.

* SHN_LOOS through SHN_HIOS
  Values in this inclusive range are reserved for operating system-specific semantics.

* SHN_ABS
  This value specifies absolute values for the corresponding
  reference. For example, symbols defined relative to section number
  SHN_ABS have absolute values and are not affected by relocation.
  当节头表索引值为SHN_ABS时，表明该符号是个绝对值，并且该值不会因为重定位而改变。
  例如，符号表表项成员st_shndx的值为SHN_ABS时，表明该符号时个文件符号（STT_FILE）。

* SHN_COMMON
  Symbols defined relative to this section are common symbols, such as
  FORTRAN COMMON or unallocated C external variables.
  当符号的节头表索引值为SHN_COMMON时，表明该符号是个公用块数据。
  例如，符号表表项成员st_shndx的值为SHN_COMMON时，表明该符号对应的实体是个公用块数据。

* SHN_XINDEX
  This value is an escape value. It indicates that the actual section header index is 
  too large to fit in the containing field and is to be found in another location (specific to the structure where it appears).
  节头表索引值SHN_XINDEX代表的是个 逸出值。它代表的意思是真实的 节头表索引值 太大，所以存储在别处。
  当e_shstrndx的值是SHN_XINDEX时，表明真实的节名表存储在第一个（即节头表索引值为0）节头表表项的成员sh_link中。

* SHN_HIRESERVE
  This value specifies the upper bound of the range of reserved
  indexes. The system reserves indexes between SHN_LORESERVE and
  SHN_HIRESERVE, inclusive; the values do not reference the section
  header table. That is, the section header table does not contain
  entries for the reserved indexes.
  系统保留SHN_LORESERVE ~ SHN_HIRESERVE的值为预留值。节头表中并不真实
  的存在这些表项。

Sections contain all information in an object file, except the ELF
header, the program header table, and the section header table. 
Moreover, object files' sections satisfy several conditions.
目标文件中除了ELF文件头、程序头表、程序段和节头表，剩下的就全都是节了。
此外，目标文件中的节符合下列条件：

* Every section in an object file has exactly one section header describing it. 
  Section headers may exist that do not have a section.
* Each section occupies one contiguous (possibly empty) sequence of
  bytes within a file.
* Sections in a file may not overlap. No byte in a file resides in
  more than one section.
* An object file may have inactive space. The various headers and the
  sections might not ``cover'' every byte in an object file. The
  contents of the inactive data are unspecified.

* 目标文件中真实存在的节都对应一个节头表索引，但是存在节头表索引，并不能说明
  目标文件中真实存在该节，例如可重定位文件中的.bss节就是存在节头表索引，但是
  在文件中该节的大小为0。
* 目标文件中的一个节所占用的空间是连续的（当然了，有的节大小可能为0，例如.bss节）。
* 目标文件中的所有节互相之间不覆盖或者重叠的。
* 目标文件中也许存在冗余的字符。由于字节对齐的需要，目标文件中有的结构（包括这个头和节）
  之间并不是连续的，而是随机填充的冗余数据，这样的数据是未定义的。

A section header has the following structure.
+ Figure 1-9: Section Header
  typedef struct {
      Elf32_Word	sh_name;		/* 节名 -- 在节名表中的索引值 */
      Elf32_Word	sh_type;		/* 节类型 -- */
      Elf32_Word	sh_flags;		/* 节标志 -- 是否可读可写可执行 */
      Elf32_Addr	sh_addr;		/* 执行时该节的虚拟地址 */
      Elf32_Off		sh_offset;		/* 该节在文件中的偏移量 */
      Elf32_Word	sh_size;		/* 节长度 */
      Elf32_Word	sh_link;		/* */
      Elf32_Word	sh_info;		/* 辅助信息 */
      Elf32_Word	sh_addralign;	/* 该节的字节对齐数 */
      Elf32_Word	sh_entsize;		/* 如果该节是个表的，那么表示每个表项的大小 */
  } Elf32_Shdr;

* sh_name
  This member specifies the name of the section. Its value is an index
  into the section header string table section [see ``String Table" below], 
  giving the location of a null-terminated string.
  成员sh_name是用来指定该节的名称的。它本身其实并不是字符串，而是一个节名表的索引值，
  在那里真正存储着该节名称的字符串文本。 

* sh_type
  This member categorizes the section's contents and semantics.
  Section types and their descriptions appear below.
  成员sh_type指定该节的类型。

* sh_flags
  Sections support 1-bit flags that describe miscellaneous attributes.
  Flag definitions appear below.
  成员sh_flags用来描述该节的诸多属性。它由一系列标志比特位组成，每一位对应
  一个属性，当具备某一属性时，相应的标志位设置为1，反之设置为0。

* sh_addr
  If the section will appear in the memory image of a process, this
  member gives the address at which the section's first byte should
  reside. Otherwise, the member contains 0.
  如果该节的数据内容最后存在于程序的内存映像中，成员sh_addr指定的是该节数据
  在内存中的起始地址。否则，即该节数据不需要映射到内存中时，该成员数值为0。

* sh_offset
  This member's value gives the byte offset from the beginning of the
  file to the first byte in the section. One section type, SHT_NOBITS
  described below, occupies no space in the file, and its sh_offset
  member locates the conceptual placement in the file.
  成员sh_offset的数值代表的意思是该节数据在目前文件中的偏移量。需要注意的是，
  当节的类型为SHT_NOBITS时，说明该节在目标文件中并不占用空间大小，所以此时
  成员sh_offset的数值代表的是概念上的偏移值。  

* sh_size
  This member gives the section's size in bytes.  Unless the section
  type is SHT_NOBITS, the section occupies sh_size bytes in the file.
  A section of type SHT_NOBITS may have a non-zero size, but it
  occupies no space in the file.
  成员sh_size说明的是该节的大小。当节的类型不是SHT_NOBITS时，成员sh_size的数值就是该节
  在目标文件中的实际大小；当节的类型是SHT_NOBITS时，尽管sh_size的数值有可能不是0，但是
  其实该节在目标文件中不占用实际大小。

* sh_link
  This member holds a section header table index link, whose
  interpretation depends on the section type. A table below describes
  the values.
  成员sh_link的数值代表的是一个节头表索引值，具体的意义解释因节的类型不同而不同。

* sh_info
  This member holds extra information, whose interpretation depends on
  the section type. A table below describes the values. 
  If the sh_flags field for this section header includes the attribute SHF_INFO_LINK, 
  then this member represents a section header table index.
  成员sh_info中包含该节的辅助信息，具体的意义解释因节的类型的不同而不同。 
  如果该节的节头表表项成员sh_flags包含属性标志SHF_INFO_LINK的话，那么sh_info
  代表的是一个节头表索引值。

* sh_addralign
  Some sections have address alignment constraints. For example, if a
  section holds a doubleword, the system must ensure doubleword
  alignment for the entire section. That is, the value of sh_addr must
  be congruent to 0, modulo the value of sh_addralign. Currently, only
  0 and positive integral powers of two are allowed. Values 0 and 1
  mean the section has no alignment constraints.
  有一些节有字节对齐的限制。例如，如果一个节中有双字节类型的数据，那么系统必须保证
  该节的字节对齐数是双字节类型大小的。也就是说，成员sh_addr的数值必须是双字节类型大小
  的整数倍。目前，成员sh_addralign的数值只能是0或者其他2的整数幂数值。数值0和1代表的是
  该节没有字节对齐要求。

* sh_entsize
  Some sections hold a table of fixed-size entries, such as a symbol
  table. For such a section, this member gives the size in bytes of
  each entry. The member contains 0 if the section does not hold a
  table of fixed-size entries.
  有一些节的数据内容是固定大小的表，例如符号表。对于这样的节，成员sh_entsize给出的是每个
  表项的大小。如果该成员数值为0，则说明该节的数据内容并不是一张表。

A section header's sh_type member specifies the section's semantics.
节头表表项成员sh_type直接该节的类型。
+ Figure 1-10: Section Types, sh_type
  Name               Value
  ====               =====
  SHT_NULL              0
  SHT_PROGBITS          1
  SHT_SYMTAB            2
  SHT_STRTAB	        3
  SHT_RELA	         	4
  SHT_HASH	         	5
  SHT_DYNAMIC           6
  SHT_NOTE	         	7
  SHT_NOBITS	        8
  SHT_REL	         	9
  SHT_SHLIB             10
  SHT_DYNSYM            11
  SHT_INIT_ARRAY		14
  SHT_FINI_ARRAY		15
  SHT_PREINIT_ARRAY		16
  SHT_GROUP				17
  SHT_SYMTAB_SHNDX		18
  SHT_LOOS		0x60000000
  SHT_HIOS		0x6fffffff
  SHT_LOPROC    0x70000000
  SHT_HIPROC    0x7fffffff
  SHT_LOUSER    0x80000000
  SHT_HIUSER    0xffffffff

* SHT_NULL
  This value marks the section header as inactive; it does not have an
  associated section. Other members of the section header have
  undefined values.
  当节头表表项成员sh_type类型为SHT_NULL时，表明该节头表表项是无效的（非活动的），目标文件中没有
  它对应的节，其他成员的值是未定义的（当e_shnum的值为0（SHN_UNDEF）时，真正的节个数不是存储在该表项的sh_size中吗
  还有e_shstrndx，怎么不提下?）。

* SHT_PROGBITS
  The section holds information defined by the program, whose format
  and meaning are determined solely by the program.
  当节的类型是SHT_PROGBITS时表明该节中有程序定义的信息，这些信息的格式和
  意义完全是由程序定义的。

* SHT_SYMTAB and SHT_DYNSYM
  These sections hold a symbol table. Currently, an object file may
  have only one section of each type, but this restriction may be
  relaxed in the future. Typically, SHT_SYMTAB provides symbols for
  link editing, though it may also be used for dynamic linking. As a
  complete symbol table, it may contain many symbols unnecessary for
  dynamic linking. Consequently, an object file may also contain a
  SHT_DYNSYM section, which holds a minimal set of dynamic linking
  symbols, to save space. See ``Symbol Table'' below for details.
  当节的类型是SHT_SYMTAB或者SHT_DYNSYM时，表明该节的数据内容是符号表。
  目前的目标文件中，每种类型的节只有一个，在将来会考虑增加节的个数。
  一般情况下，类型为SHT_SYMTAB的节是为链接器提供符号信息，尽管有的符号在程序运行时
  也会被动态链接器用到 -- SHT_SYMTAB类型的节中包含的是所有的符号信息，因此也就包含了
  很多动态链接器不需要的符号信息，为了动态链接的方便和高效，一般可执行文件中还包含
  一个类型为SHT_DYNSYM的节，该节包含的完全是动态链接器要用到的符号信息。

* SHT_STRTAB
  The section holds a string table. An object file may have multiple
  string table sections. See ``String Table'' below for details.
  当节的类型是SHT_STRTAB时表明该节是个字符串表。目标文件中可以包含多个
  字符串表（.dynstr/.shstrtab/.strtab）

* SHT_RELA
  The section holds relocation entries with explicit addends, such as
  type Elf32_Rela for the 32-bit class of object files. An object file
  may have multiple relocation sections.  See ``Relocation'' below for
  details.
  （怎么翻译呢）

* SHT_HASH
  The section holds a symbol hash table. All objects participating in
  dynamic linking must contain a symbol hash table. Currently, an
  object file may have only one hash table, but this restriction may
  be relaxed in the future. See ``Hash Table'' in Part 2 for details.
  当节的类型是SHT_HASH时，表明该节的数据内容一个符号哈希表。所有参与动态链接的目标
  文件必须有个符号哈希表。目前，一个目标文件只能有一个符号哈希表，但是这个限制将来
  可能会取消。

* SHT_DYNAMIC
  The section holds information for dynamic linking. Currently, an
  object file may have only one dynamic section, but this restriction
  may be relaxed in the future. See ``Dynamic Section'' in Part 2 for
  details.
  当节的类型是SHT_DYNAMIC时，那么该节数据内容提供的是关于动态链接的信息。
  目前，一个目标文件只能包含一个类型为SHT_DYNAMIC的节，但是这个限制将来可能
  会取消。

* SHT_NOTE
  The section holds information that marks the file in some way. See
  ``Note Section'' in Part 2 for details.
  （怎么翻译呢）

* SHT_NOBITS
  A section of this type occupies no space in the file but otherwise
  resembles SHT_PROGBITS. Although this section contains no bytes, the
  sh_offset member contains the conceptual file offset.
  当节的类型是SHT_NOBITS时，表明该节在目标文件中不占用任何空间，其他的性质和类型为SHT_PROGBITS的节很相像。
  在说明sh_offset时提到过，尽管该类型的节不占用目标文件的空间，但是此时sh_offset还是给出了概念上的文件偏移值。

* SHT_REL
  The section holds relocation entries without explicit addends, such
  as type Elf32_Rel for the 32-bit class of object files. An object
  file may have multiple relocation sections. See ``Relocation'' below
  for details.
  （怎么翻译呢）

* SHT_SHLIB
  This section type is reserved but has unspecified
  semantics. Programs that contain a section of this type do not
  conform to the ABI.

* SHT_INIT_ARRAY
  This section contains an array of pointers to initialization functions, as described in 
  ``Initialization and Termination Functions'' in Chapter 5. Each pointer in the array is 
  taken as a parameterless procedure with a void return.

* SHT_FINI_ARRAY
  This section contains an array of pointers to termination functions, as described in 
  ``Initialization and Termination Functions'' in Chapter 5. Each pointer in the array is 
  taken as a parameterless procedure with a void return.

* SHT_PREINIT_ARRAY
  This section contains an array of pointers to functions that are invoked before 
  all other initialization functions, as described in ``Initialization and Termination Functions'' in Chapter 5. 
  Each pointer in the array is taken as a parameterless procedure with a void return.

* SHT_GROUP
  This section defines a section group. A section group is a set of sections that are related 
  and that must be treated specially by the linker (see below for further details). 
  Sections of type SHT_GROUP may appear only in relocatable objects (objects with the ELF header e_type member set to ET_REL). 
  The section header table entry for a group section must appear in the section header table 
  before the entries for any of the sections that are members of the group.

* SHT_SYMTAB_SHNDX
  This section is associated with a section of type SHT_SYMTAB and is required if any of 
  the section header indexes referenced by that symbol table contain the escape value SHN_XINDEX. 
  The section is an array of Elf32_Word values. Each value corresponds one to one with a symbol table entry 
  and appear in the same order as those entries. The values represent the section header indexes against which 
  the symbol table entries are defined. Only if corresponding symbol table entry's st_shndx field contains 
  the escape value SHN_XINDEX will the matching Elf32_Word hold the actual section header index; 
  otherwise, the entry must be SHN_UNDEF (0).

* SHT_LOOS through SHT_HIOS
  Values in this inclusive range are reserved for operating system-specific semantics.

* SHT_LOPROC through SHT_HIPROC
  Values in this inclusive range are reserved for processor-specific semantics.

* SHT_LOUSER
  This value specifies the lower bound of the range of indexes
  reserved for application programs.

* SHT_HIUSER
  This value specifies the upper bound of the range of indexes
  reserved for application programs. Section types between SHT_LOUSER
  and SHT_HIUSER may be used by the application, without conflicting
  with current or future system-defined section types.

Other section type values are reserved. As mentioned before, the
section header for index 0 (SHN_UNDEF) exists, even though the index
marks undefined section references. This entry holds the following.
其他的节类型值是保留不使用的。

+ Figure 1-11: Section Header Table Entry: Index 0
  Name            Value    Note
  ====            =====    ====
  sh_name           0      No name
  sh_type        SHT_NULL  Inactive
  sh_flags          0      No flags
  sh_addr           0      No address
  sh_offset         0      No file offset
  sh_size           0      If non-zero, the actual number of section header entries 
  sh_link			0	   If non-zero, the index of the section header string table section	
  sh_info	    	0      No auxiliary information
  sh_addralign	    0      No alignment
  sh_entsize        0      No entries


A section header's sh_flags member holds 1-bit flags that describe the
section's attributes. Defined values appear below; other values are
reserved.
节头表表项中成员sh_flags用来描述该节的各种属性。
节头表表项成员sh_flags中一个位对应该节的一个属性，当某种属性设置时，相应位
设置为1，反之设置为0。

+ Figure 1-12: Section Attribute Flags, sh_flags
  Name                Value
  ====                =====
  SHF_WRITE             0x1
  SHF_ALLOC             0x2
  SHF_EXECINSTR         0x4
  SHF_MERGE				0x10
  SHF_STRINGS			0x20
  SHF_INFO_LINK			0x40
  SHF_LINK_ORDER		0x80
  SHF_OS_NONCONFORMING	0x100
  SHF_GROUP				0x200
  SHF_TLS				0x400
  SHF_COMPRESSED		0x800
  SHF_MASKOS			0x0ff00000
  SHF_MASKPROC			0xf0000000

If a flag bit is set in sh_flags, the attribute is ``on'' for the
section. Otherwise, the attribute is ``off'' or does not apply.
Undefined attributes are set to zero.
当成员sh_flags的某个位设置为1时，说明该节具备相应的属性。反之，则说明
该节不具备相应的属性。

* SHF_WRITE
  The section contains data that should be writable during process
  execution.
  属性标志SHF_WRITE说明当该程序在运行时，该节的数据是可写的。

* SHF_ALLOC
  The section occupies memory during process execution. Some control
  sections do not reside in the memory image of an object file; this
  attribute is off for those sections.
  属性标志SHF_ALLOC说明当该程序在运行时，该节的数据是要占用内存空间的。
  并不是目标文件中所有的节都会占用内存空间，例如有的起控制作用的节，在程序加载到
  内存空间时，并不会加载进内存，即程序的内存映像中不需要这些节的信息，所以
  该节就不需要SHF_ALLOC属性。

* SHF_EXECINSTR
  The section contains executable machine instructions.
  属性标志SHF_EXECINSTR标明该节包含可执行的机器指令。

* SHF_MERGE
  The data in the section may be merged to eliminate duplication. Unless the SHF_STRINGS flag is also set, 
  the data elements in the section are of a uniform size. The size of each element is specified in the section header's 
  sh_entsize field. If the SHF_STRINGS flag is also set, the data elements consist of null-terminated character strings. 
  The size of each character is specified in the section header's sh_entsize field.
  属性标志SHF_MERGE表明该节的数据有可能会被合并，从而来消除不必要的数据重复。当该节没有设置属性标志SHF_STRINGS时，那么
  该节的数据元素大小是固定的 -- 由成员sh_entsize来指定该固定大小数值。如果设置了属性标志SHF_STRINGS的话，表明该节数据元素
  是以空字符结尾的字符串 -- 而每个字符的大小由成员sh_entsize来指定。

  Each element in the section is compared against other elements in sections with the same name, type and flags. 
  Elements that would have identical values at program run-time may be merged. Relocations referencing elements of 
  such sections must be resolved to the merged locations of the referenced values. Note that any relocatable values, 
  including values that would result in run-time relocations, must be analyzed to determine whether the run-time values 
  would actually be identical. An ABI-conforming object file may not depend on specific elements being merged, 
  and an ABI-conforming link editor may choose not to merge specific elements.

* SHF_STRINGS
  The data elements in the section consist of null-terminated character strings. 
  The size of each character is specified in the section header's sh_entsize field.
  属性标志SHF_STRINGS表明该节包含的是以空字符结尾的字符串，并且每个字符的大小有成员
  sh_entsize指定。

* SHF_INFO_LINK
  The sh_info field of this section header holds a section header table index.
  当设置了属性标志SHF_INFO_LINK时，那么成员sh_info中包含的是一个节头表索引值。 

* SHF_LINK_ORDER
  This flag adds special ordering requirements for link editors. The requirements apply if 
  the sh_link field of this section's header references another section (the linked-to section). 
  If this section is combined with other sections in the output file, it must appear in the same relative order 
  with respect to those sections, as the linked-to section appears with respect to sections the linked-to section is combined with.


  []A typical use of this flag is to build a table that references text or data sections in address order.

* SHF_MASKPROC
  All bits included in this mask are reserved for processor-specific
  semantics.


Two members in the section header, sh_link and sh_info, hold special
information, depending on section type.

+ Figure 1-13: sh_link and sh_info Interpretation

  sh_type      sh_link                        sh_info
  =======      =======                        =======
  SHT_DYNAMIC  The section header index of    0
               the string table used by
               entries in the section.
  SHT_HASH     The section header index of    0
               the symbol table to which the
               hash table applies.

  SHT_REL,     The section header index of    The section header index of
  SHT_RELA     the associated symbol table.   the section to which the
                                              relocation applies.

  SHT_SYMTAB,  The section header index of    One greater than the symbol
  SHT_DYNSYM   the associated string table.   table index of the last local
                                              symbol (binding STB_LOCAL).
  other        SHN_UNDEF                      0


			   Special Sections

Various sections hold program and control information. Sections in the
list below are used by the system and have the indicated types and
attributes.

+ Figure 1-14: Special Sections

  Name         Type           Attributes
  ====         ====           ==========
  .bss         SHT_NOBITS     SHF_ALLOC+SHF_WRITE
  .comment     SHT_PROGBITS   none
  .data        SHT_PROGBITS   SHF_ALLOC+SHF_WRITE
  .data1       SHT_PROGBITS   SHF_ALLOC+SHF_WRITE
  .debug       SHT_PROGBITS   none
  .dynamic     SHT_DYNAMIC    see below
  .dynstr      SHT_STRTAB     SHF_ALLOC
  .dynsym      SHT_DYNSYM     SHF_ALLOC
  .fini        SHT_PROGBITS   SHF_ALLOC+SHF_EXECINSTR
  .got         SHT_PROGBITS   see below
  .hash        SHT_HASH       SHF_ALLOC
  .init        SHT_PROGBITS   SHF_ALLOC+SHF_EXECINSTR
  .interp      SHT_PROGBITS   see below
  .line        SHT_PROGBITS   none
  .note        SHT_NOTE       none
  .plt         SHT_PROGBITS   see below
  .rel<name>   SHT_REL        see below
  .rela<name>  SHT_RELA       see below
  .rodata      SHT_PROGBITS   SHF_ALLOC
  .rodata1     SHT_PROGBITS   SHF_ALLOC
  .shstrtab    SHT_STRTAB     none
  .strtab      SHT_STRTAB     see below
  .symtab      SHT_SYMTAB     see below
  .text        SHT_PROGBITS   SHF_ALLOC+SHF_EXECINSTR

* .bss

  This section holds uninitialized data that contribute to the
  program's memory image. By definition, the system initializes the
  data with zeros when the program begins to run. The section occupies
  no file space, as indicated by the section type, SHT_NOBITS.

* .comment

  This section holds version control information.

* .data and .data1

  These sections hold initialized data that contribute to the
  program's memory image.

* .debug

  This section holds information for symbolic debugging. The contents
  are unspecified.

* .dynamic

  This section holds dynamic linking information. The section's
  attributes will include the SHF_ALLOC bit. Whether the SHF_WRITE bit
  is set is processor specific. See Part 2 for more information.

* .dynstr

  This section holds strings needed for dynamic linking, most commonly
  the strings that represent the names associated with symbol table
  entries. See Part 2 for more information.

* .dynsym

  This section holds the dynamic linking symbol table, as ``Symbol
  Table'' describes. See Part 2 for more information.

* .fini

  This section holds executable instructions that contribute to the
  process termination code. That is, when a program exits normally,
  the system arranges to execute the code in this section.

* .got

  This section holds the global offset table. See ``Special Sections''
  in Part 1 and ``Global Offset Table'' in Part 2 for more
  information.

* .hash

  This section holds a symbol hash table. See ``Hash Table'' in Part 2
  for more information.

* .init

  This section holds executable instructions that contribute to the
  process initialization code. That is, when a program starts to run,
  the system arranges to execute the code in this section before
  calling the main program entry point (called main for C programs).

* .interp

  This section holds the path name of a program interpreter. If the
  file has a loadable segment that includes the section, the section's
  attributes will include the SHF_ALLOC bit; otherwise, that bit will
  be off. See Part 2 for more information.

* .line

  This section holds line number information for symbolic debugging,
  which describes the correspondence between the source program and
  the machine code. The contents are unspecified.

* .note

  This section holds information in the format that ``Note Section''
  in Part 2 describes.

* .plt

  This section holds the procedure linkage table. See ``Special
  Sections'' in Part 1 and ``Procedure Linkage Table'' in Part 2 for
  more information.

* .rel<name> and .rela<name>

  These sections hold relocation information, as ``Relocation'' below
  describes. If the file has a loadable segment that includes
  relocation, the sections' attributes will include the SHF_ALLOC bit;
  otherwise, that bit will be off. Conventionally, <name> is supplied
  by the section to which the relocations apply. Thus a relocation
  section for .text normally would have the name .rel.text or
  .rela.text.

* .rodata and .rodata1

  These sections hold read-only data that typically contribute to a
  non-writable segment in the process image. See ``Program Header'' in
  Part 2 for more information.

* .shstrtab

  This section holds section names.

* .strtab

  This section holds strings, most commonly the strings that represent
  the names associated with symbol table entries. If the file has a
  loadable segment that includes the symbol string table, the
  section's attributes will include the SHF_ALLOC bit; otherwise, that
  bit will be off.

* .symtab

  This section holds a symbol table, as ``Symbol Table'' in this
  section describes. If the file has a loadable segment that includes
  the symbol table, the section's attributes will include the
  SHF_ALLOC bit; otherwise, that bit will be off.

* .text

  This section holds the ``text,'' or executable instructions, of a
  program.

Section names with a dot (.) prefix are reserved for the system,
although applications may use these sections if their existing
meanings are satisfactory. Applications may use names without the
prefix to avoid conflicts with system sections. The object file format
lets one define sections not in the list above. An object file may
have more than one section with the same name.

Section names reserved for a processor architecture are formed by
placing an abbreviation of the architecture name ahead of the section
name. The name should be taken from the architecture names used for
e_machine. For instance .FOO.psect is the psect section defined by the
FOO architecture. Existing extensions are called by their historical
names.

		       Pre-existing Extensions
		       =======================
			 .sdata     .tdesc
			 .sbss      .lit4
			 .lit8      .reginfo
			 .gptab     .liblist
			 .conflict


   ========================= String Table =========================
							  字符串表
String table sections hold null-terminated character sequences,
commonly called strings. The object file uses these strings to
represent symbol and section names. One references a string as an
index into the string table section. The first byte, which is index
zero, is defined to hold a null character. Likewise, a string table's
last byte is defined to hold a null character, ensuring null
termination for all strings. A string whose index is zero specifies
either no name or a null name, depending on the context. An empty
string table section is permitted; its section header's sh_size member
would contain zero. Non-zero indexes are invalid for an empty string
table.
字符串表节（string table sections）中存储若干以空字符结尾的字符串序列，
即通常我们说的字符串。在目标文件中，使用这些字符串来表示符号名称和节的
名称。当需要使用这些字符串时，只需要提供字符串在字符串表中的索引值即可。
字符串表的第一个字节，即索引值为0对应的字节中存储的是空字符。同样的，因为
所有的字符串都是空字符结尾，所以字符串表的最后一个字节中存储的也是空字符。
索引值为0的字符串代表的是没有名字或者名字为空。一个空的字符串表是允许的，
这种情况下，它的节头表表项成员sh_size数值为0，意思是该节大小为0，所以此时提供
一个非零的字符串表索引值是非法的。

A section header's sh_name member holds an index into the section
header string table section, as designated by the e_shstrndx member of
the ELF header. The following figures show a string table with 25
bytes and the strings associated with various indexes.
一个目标文件中一般包含多个字符串表（.dynstr/.shstrtab/.strtab），其中.shstrtab节中存储的
是所有节的名字字符串。节头表表项成员sh_name代表的就是该节在.shstrtab中的索引值，该字符串表
所在节的节头表索引值由ELF头中的e_shstrndx成员指出。 
下图展现的是一个长度为25字节的字符串表。

       Index   +0   +1   +2   +3   +4   +5   +6   +7   +8   +9
       =====   ==   ==   ==   ==   ==   ==   ==   ==   ==   ==
          0    \0   n    a    m    e    .    \0   V    a    r     
         10    i    a    b    l    e    \0   a    b    l    e
         20    \0   \0   x    x    \0


+ Figure 1-15: String Table Indexes
  Index   String
  =====   ======
      0   none
      1   "name."
      7   "Variable"
     11   "able"
     16   "able"
     24   null string

As the example shows, a string table index may refer to any byte in
the section. A string may appear more than once; references to
substrings may exist; and a single string may be referenced multiple
times. Unreferenced strings also are allowed.
从上面的列子中我们可以看到：
（1）只要是合法的索引值，就可以访问该字符串表中的任何字节。
（2）一个字符串在字符串表中允许出现多次。
（3）可以使用合法的索引值访问一个字符串的子串。
（4）只要提供索引值，一个字符串当然可以引用多次。
（5）甚至允许从不被引用的字符串的存在。


   ========================= Symbol Table =========================
							    符号表
An object file's symbol table holds information needed to locate and
relocate a program's symbolic definitions and references. A symbol
table index is a subscript into this array. Index 0 both designates
the first entry in the table and serves as the undefined symbol
index. The contents of the initial entry are specified later in this
section.
目标文件中的“符号表（symbol table）”包含的都是程序中的符号信息 -- 这些
符号代表的或许是定义（例如定义全局变量时使用的变量名，或者定义函数时使用的函数名），
或许代表的是引用（例如使用关键字extern声明的变量或函数时使用的符号名称）。当代表的
是定义时，在链接阶段链接器需要为它们重定位；当代表的是引用时，在链接阶段链接器需要
在其他编译模块定位到该符号的定义。 
符号表其实是所有符号信息的集合统称，即符号表是所有符号信息一起组成的一个数组，
所以一个 符号表索引（symbol table index） 对应该数组中的一个（符号表）表项。其中，索引值0有双重含义：一般情况下
代表的意思是指代符号表的第一个表项，然而有时一个未定义符号却也使用STN_UNDEF（0）来指定其节头表索引值。

                             Name       Value
                             ====       =====
			     			 STN_UNDEF      0

A symbol table entry has the following format.
一个符号表表项的数据结构定义如下：

+ Figure 1-16: Symbol Table Entry
  typedef struct {
      Elf32_Word	st_name;	/* 符号名称 （实际是个数值，代表的是相应字符串表索引） 			*/
      Elf32_Addr	st_value;	/* 符号数值 （根据不同的符号属性，不同的目标文件，数值意义不同）*/
      Elf32_Word	st_size;	/* 符号大小 （符号在目标文件中占用的字节数）					*/
      unsigned char	st_info;	/* 符号的类型 和 绑定属性 */
      unsigned char	st_other;	/* 符号的可见性 */
      Elf32_Half	st_shndx;	/* 符号（关联的节）的节头表索引 值 */
  } Elf32_Sym;

  The attribute of identifier: 	name 			--> st_name 
								type 			--> st_info & 0x0f
								size			--> st_size
								value			--> st_value
								storage class 	--> st_info >> 4 && st_other
								scope			--> st_other?
								linkage			--> st_info >> 4: GLOBAL->external LOCAL->internal WEAK..

	scope: An identifier's scope is where the identifier can be referenced in a program.
	storage class: An identifier's storage class determines the period during which that identifier exists in memory.(lifetime) 
	linkage: An identifier's linkage determines whether an identifier is known only in the source file where it is declared 
			 or across multiple files that are compiled, then linked together. An identifier's storage-class specifier helps 
		     determine its storage class and linkage.

* st_name
  符号的名称
  This member holds an index into the object file's symbol string
  table, which holds the character representations of the symbol
  names. If the value is non-zero, it represents a string table index
  that gives the symbol name. Otherwise, the symbol table entry has no
  name.

  st_name成员其实不是一个字符串，而是一个数值，代表的是目标文件中 字符串表 中的一个索引值，
  那里才真正存储着该符号的名称对应的字符串。如果st_name成员数值不为0，则代表该符号有符号名称。否则，说明该符号没有名称。

NOTE: External C symbols have the same names in C and object files' symbol tables.
注意：在C程序中的 具有外部链接属性的符号 的名称 和 最后生成的目标文件中的符号表中的符号名称 是相同的，这点与C++不同。

* st_value
  符号数值
  This member gives the value of the associated symbol. Depending on
  the context, this may be an absolute value, an address, etc.; details appear below.

  st_value成员给出了相应的符号值。这个符号值具体是什么意思，是要依据上下文的（主要依据不同的
  符号属性和不同的目标文件），也许是个绝对值，也许是个地址值，等等。

* st_size
  符号大小

  Many symbols have associated sizes. For example, a data object's
  size is the number of bytes contained in the object. This member
  holds 0 if the symbol has no size or an unknown size.
  很多类型的符号都是有大小属性的。例如，一个数据对象的大小指的是它实际在目标文件中占的字节数。
  st_size成员如果是0的话，说明这个符号在目标文件中不占用任何字节数（例如common symbols）或者
  当前是未知大小的（例如undefined symbols）。

* st_info
  符号的类型 和 绑定属性 
  This member specifies the symbol's type and binding attributes.  A
  list of the values and meanings appears below. The following code
  shows how to manipulate the values.

  成员st_info指定了符号的类型（低四位）和绑定属性（高四位）。不同的符号类型/符号绑定属性以及意义将在下文列出。
  下面的宏分别展现了如何操作成员st_info。通过st_info得到类型和绑定属性，以及如何通过类型和绑定属性而得到st_info。

	#define ELF32_ST_BIND(val)      	(((unsigned char) (val)) >> 4)		/* 由st_info得到符号类型		*/
	#define ELF32_ST_TYPE(val)      	((val) & 0xf)						/* 由st_info得到符号绑定属性 	*/
	#define ELF32_ST_INFO(bind, type)   (((bind) << 4) + ((type) & 0xf))	/* 由符号类型和符号绑定属性得到st_info */

	/* Legal values for ST_BIND subfield of st_info (symbol binding).  */
	#define STB_LOCAL       0       /* Local symbol */
	#define STB_GLOBAL      1       /* Global symbol */
	#define STB_WEAK        2       /* Weak symbol */
	#define STB_NUM         3       /* Number of defined types.  */

	#define STB_LOOS        10      /* Start of OS-specific */
	#define STB_GNU_UNIQUE  10      /* Unique symbol.  */
	#define STB_HIOS        12      /* End of OS-specific */

	#define STB_LOPROC      13      /* Start of processor-specific */
	#define STB_HIPROC      15      /* End of processor-specific */


	/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
	#define STT_NOTYPE      0       /* Symbol type is unspecified */
	#define STT_OBJECT      1       /* Symbol is a data object */
	#define STT_FUNC        2       /* Symbol is a code object */
	#define STT_SECTION     3       /* Symbol associated with a section */
	#define STT_FILE        4       /* Symbol's name is file name */
	#define STT_COMMON      5       /* Symbol is a common data object */
	#define STT_TLS         6       /* Symbol is thread-local data object*/
	#define STT_NUM         7       /* Number of defined types.  */

	#define STT_LOOS        10      /* Start of OS-specific */
	#define STT_GNU_IFUNC   10      /* Symbol is indirect code object */
	#define STT_HIOS        12      /* End of OS-specific */

	#define STT_LOPROC      13      /* Start of processor-specific */
	#define STT_HIPROC      15      /* End of processor-specific */

* st_other
  符号的可见性
  This member currently specifies a symbol's visibility. A list of 
  the values and meanings appears below. The following code shows 
  how to manipulate the values for both 32 and 64-bit objects. Other 
  bits contain 0 and have no defined meaning. 

  st_other成员目前指定符号的可见性属性。不同的可见性属性值以及意义将在文章后续给出。
  下面的宏分别展示了在32位和64位机器上如何操作st_other。出了低两位，其余的位都为0并且没有意义。

  	#define ELF32_ST_VISIBILITY(o)  ((o) & 0x03)				
  	#define ELF64_ST_VISIBILITY(o)  ELF32_ST_VISIBILITY (o)

  	#define STV_DEFAULT 	0       /* Default symbol visibility rules */
	#define STV_INTERNAL    1       /* Processor specific hidden class */
	#define STV_HIDDEN  	2       /* Sym unavailable in other modules */
	#define STV_PROTECTED   3       /* Not preemptible, not exported */

* st_shndx
  符号（关联的节）的节头表索引值
  Every symbol table entry is ``defined'' in relation to some section;
  this member holds the relevant section header table index. As the 
  sh_link and sh_info interpretation table and the related text describe, 
  some section indexes indicate special meanings.

  每一个符号表项所代表的特定符号信息都是和一个特定的 “节” 相关联的，st_shndx成员
  代表的就是这个特定“节”的节头表索引（比如一个定义的全局变量global，那么符号global
  的属性st_shndx值应该就是.data节所对应的节头表索引；定义的函数foo，那么符号foo
  的属性st_shndx值应该就是.text节所对应的节头表索引）。部分符号的节头表索引会有特殊的含义。

  If this member contains SHN_XINDEX, then the actual section header index is too large 
  to fit in this field. The actual value is contained in the associated section of type SHT_SYMTAB_SHNDX.
  如果这个成员的值是SHN_XINDEX时，证明该符号关联的节的节头表索引值过大，超出了st_shndx所能代表的最大数值。
  那么真正的节头表索引值存储在一个类型为SHT_SYMTAB_SHNDX的扩展节中。

A symbol's binding determines the linkage visibility and behavior.
一个符号的绑定属性决定了该符号在链接阶段的可见性以及链接时的处理方式。
例如全局符号和本地符号的链接可见性是不同的，而当出现同名的全局符号和弱符号
时，链接器会做出相应的处理（这点可参考下文对全局符号和弱符号不同点的描述）。
+ Figure 1-17: Symbol Binding, ELF32_ST_BIND
  Name        Value
  ====        =====
  STB_LOCAL       0
  STB_GLOBAL      1
  STB_WEAK        2
  STB_LOPROC     13
  STB_HIPROC     15

* STB_LOCAL	本地符号
  Local symbols are not visible outside the object file containing
  their definition. Local symbols of the same name may exist in
  multiple files without interfering with each other.
  当一个符号的绑定属性是STB_LOCAL时，则表明该符号的链接属性是internal的，
  对其他目标文件来说是不可见的，即不可访问。所以不同的目标文件中的本地符号
  可以同名，它们彼此不会干扰对方。

* STB_GLOBAL 全局符号
  Global symbols are visible to all object files being combined. One
  file's definition of a global symbol will satisfy another file's
  undefined reference to the same global symbol.
  当一个符号的绑定属性是STB_GLOBAL时，则表明该符号的链接属性是external的，
  对其他目标文件来说是可见的，即可以访问。

* STB_WEAK 弱符号
  Weak symbols resemble global symbols, but their definitions have
  lower precedence.
  当一个符号的绑定属性是STB_WEAK时，则表明该符号是个弱符号，它和全局符号有类似的
  地方，即链接属性也是external的。但是链接器处理弱符号的优先级相对全局符号要低，即
  当全局符号和弱符号同名时，链接器最后使用全局符号而忽略弱符号。

* STB_LOOS through STB_HIOS
  Values in this inclusive range are reserved for operating system-specific semantics.

* STB_LOPROC through STB_HIPROC
  Values in this inclusive range are reserved for processor-specific
  semantics.

Global and weak symbols differ in two major ways.
全局符号和弱符号的区别主要在两个方面。
* When the link editor combines several relocatable object files, it
  does not allow multiple definitions of STB_GLOBAL symbols with the
  same name. On the other hand, if a defined global symbol exists, the
  appearance of a weak symbol with the same name will not cause an
  error. The link editor honors the global definition and ignores the
  weak ones. Similarly, if a common symbol exists (i.e., a symbol
  whose st_shndx field holds SHN_COMMON), the appearance of a weak
  symbol with the same name will not cause an error. The link editor
  honors the common definition and ignores the weak ones.
  当链接器链接几个可重定位文件时，它是不允许具有STB_GLOBAL属性的符号
  以相同名字进行重复定义的。而如果一个已定义的全局符号存在，则即便另
  一个具有相同名字的弱符号存在也不会引起错误。链接器将认可全局符号的
  定义而忽略弱符号的定义。与此类似的，如果一个符号被放在COMMON块（就
  是说这个符号的st_shndx成员的值为SHN_COMMON),则一个同名的弱符号也不
  会引起错误。链接器同样认可放在COMMON块符号的定义而忽略其他的弱符号。 

-----------------------------------------------------------------------
>>>	STB_GLOBAL > SHN_COMMON > STB_WEAK
-----------------------------------------------------------------------

* When the link editor searches archive libraries, it extracts archive
  members that contain definitions of undefined global symbols. The
  member's definition may be either a global or a weak symbol. 

  当程序使用静态库时，链接器会自动去搜索静态库，并且根据程序中未定义的全局
  符号选择性的提取出静态库中的可重定位文件，在这提取出的可重定位文件中就包
  含着未定义全局符号的完整定义 -- 当然了，这里的定义本身可以是全局符号，也
  可以是弱符号。

  The link editor does not extract archive members to resolve undefined
  weak symbols. Unresolved weak symbols have a zero value. The use of –z weakextract 
  overrides this default behavior. This options enables weak references to cause 
  the extraction of archive members.

  但是链接器默认是不会为了解析一个未定义的弱符号而去搜索静态库的，而是将该弱符号
  初始化为0。如果使用了–z weakextract选项的话，链接器依然会去提取静态库中的成员。

NOTE: The behavior of weak symbols in areas not specified by this document 
is implementation defined. Weak symbols are intended primarily for use in system software. 
Applications using weak symbols are unreliable since changes in the runtime environment 
might cause the execution to fail.

[wikipedia]Weak symbols are not mentioned by C or C++ language standards; as such, inserting them into 
code is not very portable. Even if two platforms support the same or similar syntax for 
marking symbols as weak, the semantics may differ in subtle points, e.g. whether weak symbols during 
dynamic linking at runtime lose their semantics or not.

注意： 弱符号的行为是实现相关的，C/C++标准中并没有弱符号的概念。弱符号主要用于系统软件中，不推荐在应用程序
中使用弱符号。

In each symbol table, all symbols with STB_LOCAL binding precede the
weak and global symbols. As ``Sections'' above describes, a symbol
table section's sh_info section header member holds the symbol table
index for the first non-local symbol.
在符号表中，不同绑定属性的符号所在位置是不同的 -- 所有的本地符号都被安放
在符号表的前头，紧接着的才是全局符号和弱符号。前文提到过，一个符号表节对
应的节头表项的节头表成员sh_info中的数值代表的是第一个绑定属性为非STB_LOCAL
的符号的符号表索引值（即最后一个绑定属性为STB_LOCAL符号的符号表索引值加1）。


A symbol's type provides a general classification for the associated
entity.
一个符号的类型为该符号关联的实体进行分类。
+ Figure 1-18: Symbol Types, ELF32_ST_TYPE
  Name         Value
  ====         =====
  STT_NOTYPE       0
  STT_OBJECT       1
  STT_FUNC         2
  STT_SECTION      3
  STT_FILE         4
  STT_LOPROC      13
  STT_HIPROC      15

* STT_NOTYPE
  The symbol's type is not specified.
  当符号类型是STT_NOTYPE时，表明该符号未指定类型或者当前还不知道该符号的类型。

* STT_OBJECT
  The symbol is associated with a data object, such as a variable, an
  array, etc.
  当符号类型是STT_OBJECT时，表明该符号关联的实体是个数据对象，例如一个变量，数组等。

* STT_FUNC 函数符号
  The symbol is associated with a function or other executable code.
  当符号类型是STT_FUNC时，表明该符号关联的实体是个函数或者其他的可执行代码。

* STT_SECTION
  The symbol is associated with a section. Symbol table entries of
  this type exist primarily for relocation and normally have STB_LOCAL binding.
  当符号类型是STT_SECTION时，表明该符号关联的实体是个节。一般符号表中的一个符号是这个
  类型时，主要是用于重定位的目的，并且其绑定属性一般情况下是STB_LOCAL。
	// 比如？

* STT_FILE 文件符号
  Conventionally, the symbol's name gives the name of the source file
  associated with the object file. A file symbol has STB_LOCAL binding, 
  its section index is SHN_ABS, and it precedes the other STB_LOCAL 
  symbols for the file, if it is present.
  通常情况下，当一个符号的类型是STT_FILE时，这个符号的名称就是该目标文件
  相关联的源文件的名称。这种类型的符号的绑定属性是STB_LOCAL的，与它相
  关的节的节头表索引值为SHN_ABS，并且如果在符号表中存在此种符号的话，那么
  其位置排在本地符号（STB_LOCAL）的前头。

* STT_COMMON
  The symbol labels an uninitialized common block. 
  当符号类型是STT_COMMON时，表明该符号是个公用块数据对象，并且这个公用块
  在目标文件中实际是未被分配空间的。 

* STT_TLS
  The symbol specifies a Thread-Local Storage entity. When defined, it 
  gives the assigned offset for the symbol, not the actual address. 
  Symbols of type STT_TLS can be referenced by only special thread-local storage relocations 
  and thread-local storage relocations can only reference symbols with type STT_TLS. 
  Implementation need not support thread-local storage.
  当符号的类型是STT_TLS时，表明该符号对应变量存储在线程局部存储内。

* STT_LOOS through STT_HIOS
  Values in this inclusive range are reserved for operating system-specific semantics.

* STT_LOPROC through STT_HIPROC
  Values in this inclusive range are reserved for processor-specific
  semantics.

Function symbols (those with type STT_FUNC) in shared object files
have special significance. When another object file references a
function from a shared object, the link editor automatically creates a
procedure linkage table entry for the referenced symbol. Shared object
symbols with types other than STT_FUNC will not be referenced
automatically through the procedure linkage table.
链接器对那些存在于共享库中的函数符号（即那些符号类型为STT_FUNC的符号）有特殊的处理。
当其它的目标文件引用了共享库中的函数时，链接器会自动的为这个引用符号创建一个 程序连接表（PLT）
表项。而共享库中符号类型为非STT_FUNC的符号则不是通过 程序连接表（PLT）自动访问。
例如，可执行程序引用共享库中的共享对象（即符号类型为STT_OBJECT的符号）时，链接器会创建一个copy reloc来解决。

Symbols with type STT_COMMON label uninitialized common blocks. 
In relocatable objects, these symbols are not allocated and must 
have the special section index SHN_COMMON. In shared objects and 
executables these symbols must be allocated to some section in the defining object.
当一个符号的类型是STT_COMMON时，则表明该符号是个公用块数据对象，且这个公用块在目标文件中
实际是未被分配空间。在可重定位文件中，并不会为这些符号分配空间，并且与之相关的节的节头表索引值
必须是SHN_COMMON。但是在共享库和可执行文件中，这些符号必须在相应的节（bss）中分配空间。

In relocatable objects, symbols with type STT_COMMON are treated just as other 
symbols with index SHN_COMMON. If the link-editor allocates space for the 
SHN_COMMON symbol in an output section of the object it is producing, 
it must preserve the type of the output symbol as STT_COMMON.
在可重定位文件中，对符号类型是STT_COMMON的符号的处理方式跟那些与之相关节的节头表索引值为SHN_COMMON的符号
的处理方式是一样的。如果链接器在生成可执行文件或者共享库时，为这类符号分配了空间的话（.bss），那么必须保留该符号的
类型为STT_COMMON.（why？ -- 下文给出） 

When the dynamic linker encounters a reference to a symbol that resolves to 
a definition of type STT_COMMON, it may (but is not required to) change 
its symbol resolution rules as follows: instead of binding the reference to 
the first symbol found with the given name, the dynamic linker searches for 
the first symbol with that name with type other than STT_COMMON. If no such 
symbol is found, it looks for the STT_COMMON definition of that name that has 
the largest size.
当动态链接器（/lib/ld-linux.so.2）遇到一个符号引用是指向符号类型是STT_COMMON的符号定义时，
那么动态链接器也许（但是并不推荐这样做）会改变符号解析的法则如下：并不会像其它类型的符号一样，
将该引用绑定到第一个同名的符号定义，而是先搜索类型为非STT_COMMON的符号定义，如果存在则绑定到
该符号定义。如果不存在，那么动态链接器这才在符号类型为STT_COMMON的定义中搜索，并且最终选择占用内存
空间最大的那个。

If a symbol's value refers to a specific location within a section,
its section index member, st_shndx, holds an index into the section
header table. As the section moves during relocation, the symbol's
value changes as well, and references to the symbol continue to
``point'' to the same location in the program. Some special section
index values give other semantics.
如果一个符号的数值代表的是其在节中特定的位置，那么该符号的节头表索引值st_shndx的值
就是该节在节头表中的索引值。因为在重定位的过程中，节的位置会变化的，
即符号的节头表索引值st_shndx值会改变，所以符号的数值st_value同样会做相应的改变，
但是该符号的引用依然”指向“该符号(!)。当符号表的节头表索引值st_shndx为下面四种特殊的
节头表索引值时有特别的含义。

* SHN_ABS
  The symbol has an absolute value that will not change because of
  relocation.
  当符号的节头表索引值为SHN_ABS时，该符号的数值是个绝对值，并且不会因为重定位而改变。

* SHN_COMMON
  The symbol labels a common block that has not yet been allocated.
  The symbol's value gives alignment constraints, similar to a
  section's sh_addralign member. That is, the link editor will
  allocate the storage for the symbol at an address that is a multiple
  of st_value. The symbol's size tells how many bytes are required.
  当符号的节头表索引值st_shndx为SHN_COMMON时，其标记的是未被分配空间的公用块。
  这种情况下，符号的数值st_value与节头表表项中的成员sh_addralign意义类似，代表
  的是该符号的对齐字节数 -- 也就是说，链接器在为该符号分配存储空间时，起始地址的值
  必须是st_value的倍数。符号大小st_size告诉链接器存储空间的大小。
  
* SHN_UNDEF
  This section table index means the symbol is undefined. When the
  link editor combines this object file with another that defines the
  indicated symbol, this file's references to the symbol will be
  linked to the actual definition.
  当符号的节头表索引值st_shndx为SHN_UNDEF（0）时，表明该符号是未定义的。那么在链接的过程
  中，链接器会在其他目标文件中找到该符号的定义，并且使其链接到实际的定义上去。

* SHN_XINDEX
  This value is an escape value. It indicates that the symbol refers to 
  a specific location within a section, but that the section header index 
  for that section is too large to be represented directly in the symbol table entry. 
  The actual section header index is found in the associated SHT_SYMTAB_SHNDX section. 
  The entries in that section correspond one to one with the entries in the symbol table. 
  Only those entries in SHT_SYMTAB_SHNDX that correspond to symbol table entries 
  with SHN_XINDEX will hold valid section header indexes; all other entries will have value 0.
  

As mentioned above, the symbol table entry for index 0 (STN_UNDEF) is reserved; it holds the following.
前面提到过，符号表的第一表项，即符号表索引值为0（STN_UNDEF）的符号表表项是保留不使用的。
它的内容如下：
+ Figure 1-19: Symbol Table Entry: Index 0
  Name        Value    Note
  ====        =====    ====
  st_name       0      No name
  st_value      0      Zero value
  st_size       0      No size
  st_info       0      No type, local binding
  st_other      0
  st_shndx  SHN_UNDEF  No section


	Symbol Values
	符号数值
Symbol table entries for different object file types have slightly
different interpretations for the st_value member.
对于符号表中的每一个符号表项来说，在不同的目标文件中，对成员st_value
的意义解释也是不同的。

* In relocatable files, st_value holds alignment constraints for a
  symbol whose section index is SHN_COMMON.
* In relocatable files, st_value holds a section offset for a defined
  symbol. That is, st_value is an offset from the beginning of the
  section that st_shndx identifies.
* In executable and shared object files, st_value holds a virtual
  address. To make these files' symbols more useful for the dynamic
  linker, the section offset (file interpretation) gives way to a
  virtual address (memory interpretation) for which the section number
  is irrelevant.
* 在可重定位文件中，当成员st_shndx等于SHN_COMMON时，则st_value的值代表的是
  该符号的对齐字节数。
* 在可重定位文件中，如果一个符号是已定义的，那么st_value的值代表的是该符号
  在其所在的节中的偏移量 -- 当然了，这个节是由st_shndx指定的。
* 在可执行文件和共行库中，st_value的值不再是一个节偏移量，而代表的是一个虚拟地址，
  直接指向符号所在的内存位置，这样做的目的是为了当该文件被加载到内存中时，这些文件中
  的符号对动态链接器（ld-linux.so.2）来说更加的有用 -- 因为虚拟地址是与节无关的，所以
  这种情况下，我们不需要关心st_shndx的值。

Although the symbol table values have similar meanings for different
object files, the data allow efficient access by the appropriate
programs.
综合以上三点可知，在不同的目标文件中st_value的值多少有所不同，这样的设计是
为了方便一些特定程序更加方便有效的访问和利用这些符号数值（例如在链接时，ld ... 在运行时，动态链接器）。


A symbol's visibility, although it may be specified in a relocatable object, 
defines how that symbol may be accessed once it has become part of an executable or shared object.
尽管我们可以在编译阶段(通过在source code中或者编译器选项指定符号的可见性)和静态链接阶段（通过export list文件）指定符号的可见性属性，
但其实可见性属性控制的是一个符号在运行时的解析行为。
+ Figure 1-20: Symbol Visibility 
		Name		   		Value
     	========   		    =====
    	STV_DEFAULT		 	  0
		STV_INTERNAL		  1
		STV_HIDDEN			  2
		STV_PROTECTED		  3

* STV_DEFAULT <<
  The visibility of symbols with the STV_DEFAULT attribute is as specified by the symbol's binding type. 
  That is, global and weak symbols are visible outside of their defining component (executable file or shared object). 
  Local symbols are hidden, as described below. Global and weak symbols are also preemptable, 
  that is, they may by preempted by definitions of the same name in another component.
  当符号的可见性是STV_DEFAULT时，那么该符号的可见性由符号的绑定属性决定。这类情况下，（可执行文件和共享库中的）全局符号和弱符号
  默认是外部可访问的，本地符号默认外部是无法被访问的。但是，可见性是STV_DEFAULT的全局符号和弱符号是可被覆盖的。
  什么意思？举个例子，共享库中的可见性值为STV_DEFAULTD的全局符号和弱符号是可被可执行文件中的同名符号覆盖的。

* STV_PROTECTED
  A symbol defined in the current component is protected if it is visible in other components but not preemptable, 
  meaning that any reference to such a symbol from within the defining component must be resolved to 
  the definition in that component, even if there is a definition in another component that would preempt 
  by the default rules. 
  A symbol with STB_LOCAL binding may not have STV_PROTECTED visibility. 
  If a symbol definition with STV_PROTECTED visibility from a shared object is taken as resolving a reference from 
  an executable or another shared object, the SHN_UNDEF symbol table entry created has STV_DEFAULT visibility.
  当符号的可见性是STV_PROTECTED时，它是外部可见的，这点跟可见性是STV_DEFAULT的一样，但不同的是它是不可覆盖的。
  这样的符号在共享库中比较常见。不可覆盖意味着如果在这个共享库访问这个符号，就一定是访问这个符号，尽管可执行文件中也
  会存在同样名字的符号也不会被覆盖掉。
  规定绑定属性为STB_LOCAL的符号的可见性不可以是STV_PROTECTED。
 

* STV_HIDDEN <<
  A symbol defined in the current component is hidden if its name is not visible to other components. 
  Such a symbol is necessarily protected. This attribute may be used to control the external interface of a component. 
  Note that an object named by such a symbol may still be referenced from another component if its address is passed outside.
  当符号的可见性是STV_HIDDEN时，证明该符号是外部无法访问的。这个属性主要用来控制共享库对外接口的数量。
  需要注意的是，一个可见性为STV_HIDDEN的数据对象，如果能获取到该符号的地址，那么依然是可以访问或者修改该数据对象的。

  A hidden symbol contained in a relocatable object must be either removed or converted to STB_LOCAL binding 
  by the link-editor when the relocatable object is included in an executable file or shared object.
  在可重定位文件中，如果一个符号的可见性是STV_HIDDEN的话，那么在链接生成可执行文件或者共享库的过程中，该符号要么
  被删除，要么绑定属性变成STB_LOCAL。
  
* STV_INTERNAL
  The meaning of this visibility attribute may be defined by processor supplements to further constrain hidden symbols. 
  A processor supplement's definition should be such that generic tools can safely treat internal symbols as hidden.

  An internal symbol contained in a relocatable object must be either removed or converted to STB_LOCAL binding 
  by the link-editor when the relocatable object is included in an executable file or shared object.

None of the visibility attributes affects resolution of symbols within an executable or shared object 
during link-editing -- such resolution is controlled by the binding type. 
Once the link-editor has chosen its resolution, these attributes impose two requirements, 
both based on the fact that references in the code being linked may have been optimized to take advantage of the attributes.

· First, all of the non-default visibility attributes, when applied to a symbol reference, 
  imply that a definition to satisfy that reference must be provided within the current executable or shared object. 
  If such a symbol reference has no definition within the component being linked, 
  then the reference must have STB_WEAK binding and is resolved to zero.

· Second, if any reference to or definition of a name is a symbol with a non-default visibility attribute, 
  the visibility attribute must be propagated to the resolving symbol in the linked object. 
  If different visibility attributes are specified for distinct references to or definitions of a symbol, 
  the most constraining visibility attribute must be propagated to the resolving symbol in the linked object. 
  The attributes, ordered from least to most constraining, are: STV_PROTECTED, STV_HIDDEN and STV_INTERNAL.

   ========================== Relocation ==========================
							  重定位信息

Relocation is the process of connecting symbolic references with
symbolic definitions. For example, when a program calls a function,
the associated call instruction must transfer control to the proper
destination address at execution. In other words, relocatable files
must have information that describes how to modify their section
contents, thus allowing executable and shared object files to hold the
right information for a process's program image. Relocation entries
are these data.
重定位操作是连接符号引用和符号定义的过程。例如，程序中调用一个函数，代码中我们
只需要指定函数名（符号引用）即可，但是当程序实际运行的时候，相关的CALL指令必须
能够正确无误地跳转到函数实际地址处（符号定义）去执行函数代码。可是在链接阶段之
前，符号的虚拟地址（亦可称运行时地址）并没有分配，只有在链接阶段的符号解析过程
中链接器才会为符号分配虚拟地址。在符号地址确认后，链接器这才会修改机器指令（即
重定位操作是在符号解析之后），可是链接器并不会聪明到可以自动找到可重定位文件中
引用外部符号的地方（即需要修改的地方），所以可重定位文件必须提供相应的信息来帮
助链接器，换句话说，可重定位文件中必须包含相关的信息来告诉链接器如何去修改节的
内容，只有这样，最后生成的可执行文件或者共享库才会包含正确的信息来构建最终的进
程映像。可重定位项就是帮助链接器进行重定位操作的信息。

+ Figure 1-20: Relocation Entries 重定位项

  typedef struct {
      Elf32_Addr	r_offset;	/* 可重定位文件：在节中的偏移值  可执行文件或者共享库：虚拟地址 */
      Elf32_Word	r_info;		/* 需要重定位的符号在符号表中的索引值 + 重定位类型 */
  } Elf32_Rel;

  typedef struct {
      Elf32_Addr	r_offset;
      Elf32_Word	r_info;
      Elf32_Sword	r_addend;
  } Elf32_Rela;

* r_offset

  This member gives the location at which to apply the relocation
  action. For a relocatable file, the value is the byte offset from
  the beginning of the section to the storage unit affected by the
  relocation. For an executable file or a shared object, the value is
  the virtual address of the storage unit affected by the relocation.

  r_offset给出的是需要做重定位操作的位置，代表的意思对于不同的文件来说有所不同。
  对可重定位文件来说，r_offset代表的是段内偏移，即需要重定位操作的地方在所在节
  中的偏移值。对于可执行文件或者共享库来说，r_offset代表的是需要重定位操作的地方de虚拟地址。

* r_info

  This member gives both the symbol table index with respect to which
  the relocation must be made, and the type of relocation to apply.
  For example, a call instruction's relocation entry would hold the
  symbol table index of the function being called. If the index is
  STN_UNDEF, the undefined symbol index, the relocation uses 0 as the
  ``symbol value.'' Relocation types are processor-specific. When the
  text refers to a relocation entry's relocation type or symbol table
  index, it means the result of applying ELF32_R_TYPE or ELF32_R_SYM,
  respectively, to the entry's r_info member.

  r_info中包含重定位类型和需要重定位的符号在符号表中的索引值。举例来说，一个跟函数重定位相关的
  重定位项中的r_info会给出该函数符号在符号表中的索引值。如果索引值是STN_UNDEF，即符号是未定义的，
  那么重定位过程中将使用0作为该符号的符号数值。重定位类型是处理器相关的一种属性。可以使用宏ELF32_R_SYM
  和宏ELF32_R_TYPE分别得到需要重定位的符号的符号表索引值以及重定位类型。

    #define ELF32_R_SYM(i)		((i) >> 8)
    #define ELF32_R_TYPE(i)		((unsigned char)(i))
    #define ELF32_R_INFO(s, t)	((s) << 8 + (unsigned char)(t))

* r_addend

  This member specifies a constant addend used to compute the value to
  be stored into the relocatable field.
  r_addend一般是个常量，用来辅助计算修订值。

As shown above, only Elf32_Rela entries contain an explicit
addend. Entries of type Elf32_Rel store an implicit addend in the
location to be modified. Depending on the processor architecture, one
form or the other might be necessary or more convenient. Consequently,
an implementation for a particular machine may use one form
exclusively or either form depending on context.
从上面的定义可以看到，Elf32_Rela和Elf32_Rel的区别仅仅是多了一个r_addend。
Elf32_Rela中用r_addend显示地指出Addend，而对于Elf32_Rel来说，它的Addend
被填充在引用外部符号的地址处，即需要进行重定位操作的地方。具体的体系结构
可以选择适合自己的一种格式，或者两种格式都使用，只不过在不同的上下文中使用
更合适的格式。

A relocation section references two other sections: a symbol table and
a section to modify. The section header's sh_info and sh_link members,
described in ``Sections'' above, specify these relationships.
Relocation entries for different object files have slightly different
interpretations for the r_offset member.
自此我们知道一个重定位节与其它两个节相关联，一个是符号表（节），另一个是
该重定位节对应的需要进行重定位操作的节，它们的节头表索引值分别由节头表成员
sh_info和sh_link指定。成员r_offset的意义因文件的不同而有所区别，如下：

* In relocatable files, r_offset holds a section offset. That is, the
  relocation section itself describes how to modify another section in
  the file; relocation offsets designate a storage unit within the
  second section.
* 如果是可重定位文件，那么r_offset的数值代表的是需要进行重定位操作的地方在所在节中的
  偏移值。也就是说，在可重定位文件中，重定位节就是描述如何修改需要进行重定位操作的
  节的内容，r_offset就是告诉链接器需要修改的地方在节中的位置。

* In executable and shared object files, r_offset holds a virtual
  address. To make these files' relocation entries more useful for the
  dynamic linker, the section offset (file interpretation) gives way
  to a virtual address (memory interpretation).
  如果是可执行文件或者共享库文件，r_offset数值代表的是一个虚拟地址。在程序运行过程中
  动态链接器会用到该虚拟地址。（为了让这些重定位项对动态链接器来说更加有用，r_offset代表的
  并不是偏移值，而是代表的虚拟地址）
  give way to

Although the interpretation of r_offset changes for different object
files to allow efficient access by the relevant programs, the
relocation types' meanings stay the same.
尽管一个重定位项中的r_offset的意义会因为文件的不同而不同，但是r_info中的
重定位类型却总是一直保持不变的。


			   Relocation Types
				 重定位类型
Relocation entries describe how to alter the following instruction and
data fields (bit numbers appear in the lower box corners).

+ Figure 1-21: Relocatable Fields 

    +---------------------------+
    |          word32           |
   31---------------------------0


* word32

  This specifies a 32-bit field occupying 4 bytes with arbitrary byte
  alignment. These values use the same byte order as other word values
  in the 32-bit Intel Architecture.

                     3------2------1------0------+
	     0x01020304  |  01  |  02  |  03  |  04  |
                    31------+------+------+------0

Calculations below assume the actions are transforming a relocatable
file into either an executable or a shared object file. Conceptually,
the link editor merges one or more relocatable files to form the
output. It first decides how to combine and locate the input files,
then updates the symbol values, and finally performs the relocation.
Relocations applied to executable or shared object files are similar
and accomplish the same result. Descriptions below use the following
notation.

* A
  This means the addend used to compute the value of the relocatable
  field.

* B

  This means the base address at which a shared object has been loaded
  into memory during execution. Generally, a shared object file is
  built with a 0 base virtual address, but the execution address will
  be different.

* G
  This means the offset into the global offset table at which the
  address of the relocation entry's symbol will reside during
  execution. See ``Global Offset Table'' in Part 2 for more
  information.

* GOT
  This means the address of the global offset table. See ``Global
  Offset Table'' in Part 2 for more information.

* L
  This means the place (section offset or address) of the procedure
  linkage table entry for a symbol. A procedure linkage table entry
  redirects a function call to the proper destination. The link editor
  builds the initial procedure linkage table, and the dynamic linker
  modifies the entries during execution. See ``Procedure Linkage
  Table'' in Part 2 for more information.

* P
  This means the place (section offset or address) of the storage unit
  being relocated (computed using r_offset).

* S
  This means the value of the symbol whose index resides in the
  relocation entry.

A relocation entry's r_offset value designates the offset or virtual
address of the first byte of the affected storage unit. The relocation
type specifies which bits to change and how to calculate their
values. The SYSTEM V architecture uses only Elf32_Rel relocation
entries, the field to be relocated holds the addend. In all cases, the
addend and the computed result use the same byte order.

+ Figure 1-22: Relocation Types

  Name            Value  Field   Calculation
  ====            =====  =====   ===========
  R_386_NONE        0    none    none
  R_386_32	        1    word32  S + A
  R_386_PC32	    2    word32  S + A - P
  R_386_GOT32	    3    word32  G + A - P
  R_386_PLT32	    4    word32  L + A - P
  R_386_COPY	    5    none    none
  R_386_GLOB_DAT    6    word32  S
  R_386_JMP_SLOT    7    word32  S
  R_386_RELATIVE    8    word32  B + A
  R_386_GOTOFF	    9    word32  S + A - GOT
  R_386_GOTPC	   10    word32  GOT + A - P

Some relocation types have semantics beyond simple calculation.

* R_386_GOT32
  This relocation type computes the distance from the base of the
  global offset table to the symbol's global offset table entry. It
  additionally instructs the link editor to build a global offset
  table.
  重定位类型R_386_GOT32需要计算符号对应的GOT表项在GOT表中的偏移量。

* R_386_PLT32

  This relocation type computes the address of the symbol's procedure
  linkage table entry and additionally instructs the link editor to
  build a procedure linkage table.

* R_386_COPY

  The link editor creates this relocation type for dynamic linking.
  Its offset member refers to a location in a writable segment. The
  symbol table index specifies a symbol that should exist both in the
  current object file and in a shared object. During execution, the
  dynamic linker copies data associated with shared object's symbol to
  the location specified by the offset.

* R_386_GLOB_DAT

  This relocation type is used to set a global offset table entry to
  the address of the specified symbol. The special relocation type
  allows one to determine the correspondence between symbols and
  global offset table entries.

* R_386_JMP_SLOT {*}

  The link editor creates this relocation type for dynamic linking.
  Its offset member gives the location of a procedure linkage table
  entry. The dynamic linker modifies the procedure linkage table entry
  to transfer control to the designated symbol's address [see
  ``Procedure Linkage Table'' in Part 2].

* R_386_RELATIVE
  The link editor creates this relocation type for dynamic linking.
  Its offset member gives a location within a shared object that
  contains a value representing a relative address. The dynamic linker
  computes the corresponding virtual address by adding the virtual
  address at which the shared object was loaded to the relative
  address. Relocation entries for this type must specify 0 for the
  symbol table index.
  当指针类型的静态变量、全局变量指向静态变量、static函数或者字符串，并且最终
  需要生成的是共享库，那么链接阶段链接器会特地为动态链接器生成重定位类型是R_386_RELATIVE
  的重定位信息。r_offset代表的是指针变量在共享库中的偏移值，在该偏移值处存储的是指针指向变量在
  共享库文件中的偏移值。程序运行时，动态链接器只需要将共享库的加载地址和r_offset处存储的偏移值
  相加写回到r_offset偏移处即可。

* R_386_GOTOFF
  This relocation type computes the difference between a symbol's
  value and the address of the global offset table. It additionally
  instructs the link editor to build the global offset table.
  重定位类型R_386_GOTOFF需要链接器计算符号地址和GOT表之间的位置差值。
  	目标文件:R_386_GOTOFF
	共享库: NULL

* R_386_GOTPC
  This relocation type resembles R_386_PC32, except it uses the
  address of the global offset table in its calculation. The symbol
  referenced in this relocation normally is _GLOBAL_OFFSET_TABLE_,
  which additionally instructs the link editor to build the global
  offset table.
  重定位类型R_386_GOTPC跟R_386_PC32很类似，不同的是R_386_GOTPC计算的是
  PC和GOT表之间的差值，而不是PC与函数之间的差值。通常情况下，跟R_386_GOTPC相关的符号是_GLOBAL_OFFSET_TABLE_。
	目标文件: R_386_GOTPC
	共享库: NULL
   ________________________________________________________________


		2. PROGRAM LOADING AND DYNAMIC LINKING

   ________________________________________________________________


   ========================= Introduction =========================


Part 2 describes the object file information and system actions that
create running programs. Some information here applies to all systems;
other information is processor-specific.

Executable and shared object files statically represent programs. To
execute such programs, the system uses the files to create dynamic
program representations, or process images. A process image has
segments that hold its text, data, stack, and so on. The major
sections in this part discuss the following.

* Program header. This section complements Part 1, describing object
  file structures that relate directly to program execution. The
  primary data structure, a program header table, locates segment
  images within the file and contains other information necessary to
  create the memory image for the program.
* Program loading. Given an object file, the system must load it into
  memory for the program to run.
* Dynamic linking. After the system loads the program, it must
  complete the process image by resolving symbolic references among
  the object files that compose the process.

NOTE: There are naming conventions for ELF constants that have
specified processor ranges. Names such as DT_, PT_, for
processor-specific extensions, incorporate the name of the processor:
DT_M32_SPECIAL, for example. Pre-existing processor extensions not
using this convention will be supported.

		       Pre-existing Extensions
		       =======================
			      DT_JMP_REL


   ======================== Program Header ========================


An executable or shared object file's program header table is an array
of structures, each describing a segment or other information the
system needs to prepare the program for execution. An object file
segment contains one or more sections, as ``Segment Contents''
describes below. Program headers are meaningful only for executable
and shared object files. A file specifies its own program header size
with the ELF header's e_phentsize and e_phnum members [see ``ELF
Header'' in Part 1].

+ Figure 2-1: Program Header

  typedef struct {
      Elf32_Word	p_type;
      Elf32_Off		p_offset;
      Elf32_Addr	p_vaddr;
      Elf32_Addr	p_paddr;
      Elf32_Word	p_filesz;
      Elf32_Word	p_memsz;
      Elf32_Word	p_flags;
      Elf32_Word	p_align;
  } Elf32_Phdr;

* p_type

  This member tells what kind of segment this array element describes
  or how to interpret the array element's information. Type values and
  their meanings appear below.

* p_offset

  This member gives the offset from the beginning of the file at which
  the first byte of the segment resides.

* p_vaddr

  This member gives the virtual address at which the first byte of the
  segment resides in memory.

* p_paddr

  On systems for which physical addressing is relevant, this member is
  reserved for the segment's physical address. Because System V
  ignores physical addressing for application programs, this member
  has unspecified contents for executable files and shared objects.

* p_filesz

  This member gives the number of bytes in the file image of the
  segment; it may be zero.

* p_memsz

  This member gives the number of bytes in the memory image of the
  segment; it may be zero.

* p_flags

  This member gives flags relevant to the segment. Defined flag values
  appear below.

* p_align

  As ``Program Loading'' later in this part describes, loadable
  process segments must have congruent values for p_vaddr and
  p_offset, modulo the page size. This member gives the value to which
  the segments are aligned in memory and in the file. Values 0 and 1
  mean no alignment is required. Otherwise, p_align should be a
  positive, integral power of 2, and p_vaddr should equal p_offset,
  modulo p_align.

Some entries describe process segments; others give supplementary
information and do not contribute to the process image.  Defined
entries may appear in any order, except as explicitly noted
below. Segment type values follow; other values are reserved for
future use.

+ Figure 2-2: Segment Types, p_type

  Name             Value
  ====             =====
  PT_NULL              0
  PT_LOAD              1
  PT_DYNAMIC           2
  PT_INTERP            3
  PT_NOTE              4
  PT_SHLIB             5
  PT_PHDR              6
  PT_LOPROC   0x70000000
  PT_HIPROC   0x7fffffff

* PT_NULL

  The array element is unused; other members' values are undefined.
  This type lets the program header table have ignored entries.

* PT_LOAD

  The array element specifies a loadable segment, described by
  p_filesz and p_memsz. The bytes from the file are mapped to the
  beginning of the memory segment. If the segment's memory size
  (p_memsz) is larger than the file size (p_filesz), the ``extra''
  bytes are defined to hold the value 0 and to follow the segment's
  initialized area. The file size may not be larger than the memory
  size. Loadable segment entries in the program header table appear in
  ascending order, sorted on the p_vaddr member.

* PT_DYNAMIC

  The array element specifies dynamic linking information. See
  ``Dynamic Section'' below for more information.

* PT_INTERP

  The array element specifies the location and size of a
  null-terminated path name to invoke as an interpreter. This segment
  type is meaningful only for executable files (though it may occur
  for shared objects); it may not occur more than once in a file. If
  it is present, it must precede any loadable segment entry. See
  ``Program Interpreter'' below for further information.

* PT_NOTE

  The array element specifies the location and size of auxiliary
  information. See ``Note Section'' below for details.

* PT_SHLIB

  This segment type is reserved but has unspecified semantics.
  Programs that contain an array element of this type do not conform
  to the ABI.

* PT_PHDR

  The array element, if present, specifies the location and size of
  the program header table itself, both in the file and in the memory
  image of the program. This segment type may not occur more than once
  in a file. Moreover, it may occur only if the program header table
  is part of the memory image of the program. If it is present, it
  must precede any loadable segment entry. See ``Program Interpreter''
  below for further information.

* PT_LOPROC through PT_HIPROC

  Values in this inclusive range are reserved for processor-specific
  semantics.

NOTE: Unless specifically required elsewhere, all program header
segment types are optional. That is, a file's program header table may
contain only those elements relevant to its contents.


			     Base Address

Executable and shared object files have a base address, which is the
lowest virtual address associated with the memory image of the
program's object file. One use of the base address is to relocate the
memory image of the program during dynamic linking.

An executable or shared object file's base address is calculated
during execution from three values: the memory load address, the
maximum page size, and the lowest virtual address of a program's
loadable segment. As ``Program Loading'' in this chapter describes,
the virtual addresses in the program headers might not represent the
actual virtual addresses of the program's memory image. To compute the
base address, one determines the memory address associated with the
lowest p_vaddr value for a PT_LOAD segment. One then obtains the base
address by truncating the memory address to the nearest multiple of
the maximum page size. Depending on the kind of file being loaded into
memory, the memory address might or might not match the p_vaddr
values.

As ``Sections'' in Part 1 describes, the .bss section has the type
SHT_NOBITS. Although it occupies no space in the file, it contributes
to the segment's memory image. Normally, these uninitialized data
reside at the end of the segment, thereby making p_memsz larger than
p_filesz in the associated program header element.


			     Note Section

Sometimes a vendor or system builder needs to mark an object file with
special information that other programs will check for conformance,
compatibility, etc. Sections of type SHT_NOTE and program header
elements of type PT_NOTE can be used for this purpose. The note
information in sections and program header elements holds any number
of entries, each of which is an array of 4-byte words in the format of
the target processor. Labels appear below to help explain note
information organization, but they are not part of the specification.

+ Figure 2-3: Note Information

  namesz
  descsz
  type
  name ...
  desc ...

* namesz and name

  The first namesz bytes in name contain a null-terminated character
  representation of the entry's owner or originator. There is no
  formal mechanism for avoiding name conflicts. By convention, vendors
  use their own name, such as ``XYZ Computer Company,'' as the
  identifier. If no name is present, namesz contains 0. Padding is
  present, if necessary, to ensure 4-byte alignment for the
  descriptor. Such padding is not included in namesz.

* descsz and desc

  The first descsz bytes in desc hold the note descriptor. The ABI
  places no constraints on a descriptor's contents. If no descriptor
  is present, descsz contains 0. Padding is present, if necessary, to
  ensure 4-byte alignment for the next note entry. Such padding is not
  included in descsz.

* type

  This word gives the interpretation of the descriptor. Each
  originator controls its own types; multiple interpretations of a
  single type value may exist. Thus, a program must recognize both the
  name and the type to ``understand'' a descriptor. Types currently
  must be non-negative. The ABI does not define what descriptors mean.

To illustrate, the following note segment holds two entries.

+ Figure 2-4: Example Note Segment

           +0   +1   +2   +3
          -------------------
  namesz           7
  descsz           0           No descriptor
    type           1
    name   X    Y    Z    spc 
           C    o    \0   pad
  namesz           7
  descsz           8
    type           3
    name   X    Y    Z    spc
           C    o    \0   pad
    desc         word0
                 word1

NOTE: The system reserves note information with no name (namesz==0)
and with a zero-length name (name[0]=='\0') but currently defines no
types. All other names must have at least one non-null character.

NOTE: Note information is optional. The presence of note information
does not affect a program's ABI conformance, provided the information
does not affect the program's execution behavior. Otherwise, the
program does not conform to the ABI and has undefined behavior.


   ======================= Program Loading ========================


As the system creates or augments a process image, it logically copies
a file's segment to a virtual memory segment. When--and if--the system
physically reads the file depends on the program's execution behavior,
system load, etc. A process does not require a physical page unless it
references the logical page during execution, and processes commonly
leave many pages unreferenced. Therefore delaying physical reads
frequently obviates them, improving system performance. To obtain this
efficiency in practice, executable and shared object files must have
segment images whose file offsets and virtual addresses are congruent,
modulo the page size.

Virtual addresses and file offsets for the SYSTEM V architecture
segments are congruent modulo 4 KB (0x1000) or larger powers of 2.
Because 4 KB is the maximum page size, the files will be suitable for
paging regardless of physical page size.

+ Figure 2-5: Executable File

           File Offset   File                  Virtual Address
           ===========   ====                  ===============
                     0   ELF header
  Program header table
                         Other information
                 0x100   Text segment          0x8048100
                         ...
                         0x2be00 bytes         0x8073eff
               0x2bf00   Data segment          0x8074f00
                         ...
                         0x4e00 bytes          0x8079cff
               0x30d00   Other information
                         ...

+ Figure 2-6: Program Header Segments

  Member    Text	 Data
  ======    ====         ====
  p_type    PT_LOAD      PT_LOAD
  p_offset  0x100	 0x2bf00
  p_vaddr   0x8048100	 0x8074f00
  p_paddr   unspecified	 unspecified
  p_filesz  0x2be00	 0x4e00
  p_memsz   0x2be00	 0x5e24
  p_flags   PF_R+PF_X    PF_R+PF_W+PF_X
  p_align   0x1000	 0x1000

Although the example's file offsets and virtual addresses are
congruent modulo 4 KB for both text and data, up to four file pages
hold impure text or data (depending on page size and file system block
size).

* The first text page contains the ELF header, the program header
  table, and other information.
* The last text page holds a copy of the beginning of data.
* The first data page has a copy of the end of text.
* The last data page may contain file information not relevant to the
  running process.

Logically, the system enforces the memory permissions as if each
segment were complete and separate; segments' addresses are adjusted
to ensure each logical page in the address space has a single set of
permissions. In the example above, the region of the file holding the
end of text and the beginning of data will be mapped twice: at one
virtual address for text and at a different virtual address for data.

The end of the data segment requires special handling for
uninitialized data, which the system defines to begin with zero
values. Thus if a file's last data page includes information not in
the logical memory page, the extraneous data must be set to zero, not
the unknown contents of the executable file. ``Impurities'' in the
other three pages are not logically part of the process image; whether
the system expunges them is unspecified. The memory image for this
program follows, assuming 4 KB (0x1000) pages.

+ Figure 2-7: Process Image Segments

  Virtual Address  Contents            Segment
  ===============  ========            =======
        0x8048000  Header padding      Text
                   0x100 bytes
        0x8048100  Text segment
                   ...
                   0x2be00 bytes
        0x8073f00  Data padding
                   0x100 bytes
        0x8074000  Text padding        Data
                   0xf00 bytes
        0x8074f00  Data segment
                   ...
                   0x4e00 bytes
        0x8079d00  Uninitialized data
                   0x1024 zero bytes
        0x807ad24  Page padding
                   0x2dc zero bytes

One aspect of segment loading differs between executable files and
shared objects. Executable file segments typically contain absolute
code. To let the process execute correctly, the segments must reside
at the virtual addresses used to build the executable file. Thus the
system uses the p_vaddr values unchanged as virtual addresses.

On the other hand, shared object segments typically contain
position-independent code. This lets a segment's virtual address
change from one process to another, without invalidating execution
behavior. Though the system chooses virtual addresses for individual
processes, it maintains the segments' relative positions. Because
position-independent code uses relative addressing between segments,
the difference between virtual addresses in memory must match the
difference between virtual addresses in the file. The following table
shows possible shared object virtual address assignments for several
processes, illustrating constant relative positioning. The table also
illustrates the base address computations.

+ Figure 2-8: Example Shared Object Segment Addresses

  Sourc             Text        Data  Base Address
  =====             ====        ====  ============
  File             0x200     0x2a400           0x0
  Process 1   0x80000200  0x8002a400    0x80000000
  Process 2   0x80081200  0x800ab400    0x80081000
  Process 3   0x900c0200  0x900ea400    0x900c0000
  Process 4   0x900c6200  0x900f0400    0x900c6000


   ======================= Dynamic Linking ========================


			 Program Interpreter

An executable file may have one PT_INTERP program header element.
During exec(BA_OS), the system retrieves a path name from the
PT_INTERP segment and creates the initial process image from the
interpreter file's segments. That is, instead of using the original
executable file's segment images, the system composes a memory image
for the interpreter. It then is the interpreter's responsibility to
receive control from the system and provide an environment for the
application program.

The interpreter receives control in one of two ways. First, it may
receive a file descriptor to read the executable file, positioned at
the beginning. It can use this file descriptor to read and/or map the
executable file's segments into memory. Second, depending on the
executable file format, the system may load the executable file into
memory instead of giving the interpreter an open file descriptor. With
the possible exception of the file descriptor, the interpreter's
initial process state matches what the executable file would have
received. The interpreter itself may not require a second interpreter.
An interpreter may be either a shared object or an executable file.

* A shared object (the normal case) is loaded as position-independent,
  with addresses that may vary from one process to another; the system
  creates its segments in the dynamic segment area used by mmap(KE_OS)
  and related services. Consequently, a shared object interpreter
  typically will not conflict with the original executable file's
  original segment addresses.

* An executable file is loaded at fixed addresses; the system creates
  its segments using the virtual addresses from the program header
  table. Consequently, an executable file interpreter's virtual
  addresses may collide with the first executable file; the
  interpreter is responsible for resolving conflicts.


			    Dynamic Linker

When building an executable file that uses dynamic linking, the link
editor adds a program header element of type PT_INTERP to an
executable file, telling the system to invoke the dynamic linker as
the program interpreter.

NOTE: The locations of the system provided dynamic linkers are
processor-specific.

Exec(BA_OS) and the dynamic linker cooperate to create the process
image for the program, which entails the following actions:

* Adding the executable file's memory segments to the process image;
* Adding shared object memory segments to the process image;
* Performing relocations for the executable file and its shared
  objects;
* Closing the file descriptor that was used to read the executable
  file, if one was given to the dynamic linker;
* Transferring control to the program, making it look as if the
  program had received control directly from exec(BA_OS).

The link editor also constructs various data that assist the dynamic
linker for executable and shared object files. As shown above in
``Program Header,'' these data reside in loadable segments, making
them available during execution. (Once again, recall the exact segment
contents are processor-specific. See the processor supplement for
complete information.)

* A .dynamic section with type SHT_DYNAMIC holds various data. The
  structure residing at the beginning of the section holds the
  addresses of other dynamic linking information.

* The .hash section with type SHT_HASH holds a symbol hash table.

* The .got and .plt sections with type SHT_PROGBITS hold two separate
  tables: the global offset table and the procedure linkage table.
  Sections below explain how the dynamic linker uses and changes the
  tables to create memory images for object files.

Because every ABI-conforming program imports the basic system services
from a shared object library, the dynamic linker participates in every
ABI-conforming program execution.

As ``Program Loading'' explains in the processor supplement, shared
objects may occupy virtual memory addresses that are different from
the addresses recorded in the file's program header table. The dynamic
linker relocates the memory image, updating absolute addresses before
the application gains control. Although the absolute address values
would be correct if the library were loaded at the addresses specified
in the program header table, this normally is not the case.

If the process environment [see exec(BA_OS)] contains a variable named
LD_BIND_NOW with a non-null value, the dynamic linker processes all
relocation before transferring control to the program. For example,
all the following environment entries would specify this behavior.

* LD_BIND_NOW=1
* LD_BIND_NOW=on
* LD_BIND_NOW=off

Otherwise, LD_BIND_NOW either does not occur in the environment or has
a null value. The dynamic linker is permitted to evaluate procedure
linkage table entries lazily, thus avoiding symbol resolution and
relocation overhead for functions that are not called. See ``Procedure
Linkage Table'' in this part for more information.


			   Dynamic Section

If an object file participates in dynamic linking, its program header
table will have an element of type PT_DYNAMIC. This ``segment''
contains the .dynamic section. A special symbol, _DYNAMIC, labels the
section, which contains an array of the following structures.

+ Figure 2-9: Dynamic Structure

  typedef struct {
      Elf32_Sword d_tag;
      union {
          Elf32_Sword	d_val;
          Elf32_Addr	d_ptr;
      } d_un;
  } Elf32_Dyn;

  extern Elf32_Dyn _DYNAMIC[];

For each object with this type, d_tag controls the interpretation of
d_un.

* d_val

  These Elf32_Word objects represent integer values with various
  interpretations.

* d_ptr

  These Elf32_Addr objects represent program virtual addresses. As
  mentioned previously, a file's virtual addresses might not match the
  memory virtual addresses during execution. When interpreting
  addresses contained in the dynamic structure, the dynamic linker
  computes actual addresses, based on the original file value and the
  memory base address. For consistency, files do not contain
  relocation entries to ``correct'' addresses in the dynamic
  structure.

The following table summarizes the tag requirements for executable and
shared object files. If a tag is marked ``mandatory,'' then the
dynamic linking array for an ABI-conforming file must have an entry of
that type. Likewise, ``optional'' means an entry for the tag may
appear but is not required.

+ Figure 2-10: Dynamic Array Tags, d_tag

  Name               Value  d_un         Executable   Shared Object
  ====               =====  ====         ==========   =============
  DT_NULL                0  ignored	 mandatory    mandatory
  DT_NEEDED		 1  d_val	 optional     optional
  DT_PLTRELSZ		 2  d_val	 optional     optional
  DT_PLTGOT		 3  d_ptr	 optional     optional
  DT_HASH		 4  d_ptr	 mandatory    mandatory
  DT_STRTAB		 5  d_ptr	 mandatory    mandatory
  DT_SYMTAB		 6  d_ptr	 mandatory    mandatory
  DT_RELA		 7  d_ptr	 mandatory    optional
  DT_RELASZ		 8  d_val	 mandatory    optional
  DT_RELAENT		 9  d_val	 mandatory    optional
  DT_STRSZ		10  d_val	 mandatory    mandatory
  DT_SYMENT		11  d_val	 mandatory    mandatory
  DT_INIT		12  d_ptr	 optional     optional
  DT_FINI		13  d_ptr	 optional     optional
  DT_SONAME		14  d_val	 ignored      optional
  DT_RPATH		15  d_val	 optional     ignored
  DT_SYMBOLIC		16  ignored	 ignored      optional
  DT_REL		17  d_ptr	 mandatory    optional
  DT_RELSZ		18  d_val	 mandatory    optional
  DT_RELENT		19  d_val	 mandatory    optional
  DT_PLTREL		20  d_val	 optional     optional
  DT_DEBUG		21  d_ptr	 optional     ignored
  DT_TEXTREL		22  ignored	 optional     optional
  DT_JMPREL		23  d_ptr	 optional     optional
  DT_LOPROC     0x70000000  unspecified  unspecified  unspecified
  DT_HIPROC     0x7fffffff  unspecified  unspecified  unspecified

* DT_NULL

  An entry with a DT_NULL tag marks the end of the _DYNAMIC array.

* DT_NEEDED

  This element holds the string table offset of a null-terminated
  string, giving the name of a needed library. The offset is an index
  into the table recorded in the DT_STRTAB entry. See ``Shared Object
  Dependencies'' for more information about these names. The dynamic
  array may contain multiple entries with this type. These entries'
  relative order is significant, though their relation to entries of
  other types is not.

* DT_PLTRELSZ

  This element holds the total size, in bytes, of the relocation
  entries associated with the procedure linkage table. If an entry of
  type DT_JMPREL is present, a DT_PLTRELSZ must accompany it.

* DT_PLTGOT

  This element holds an address associated with the procedure linkage
  table and/or the global offset table. See this section in the
  processor supplement for details.

* DT_HASH

  This element holds the address of the symbol hash table, described
  in ``Hash Table.'' This hash table refers to the symbol table
  referenced by the DT_SYMTAB element.

* DT_STRTAB

  This element holds the address of the string table, described in
  Part 1. Symbol names, library names, and other strings reside in
  this table.

* DT_SYMTAB

  This element holds the address of the symbol table, described in
  Part 1, with Elf32_Sym entries for the 32-bit class of files.

* DT_RELA

  This element holds the address of a relocation table, described in
  Part 1. Entries in the table have explicit addends, such as
  Elf32_Rela for the 32-bit file class. An object file may have
  multiple relocation sections. When building the relocation table for
  an executable or shared object file, the link editor catenates those
  sections to form a single table. Although the sections remain
  independent in the object file, the dynamic linker sees a single
  table. When the dynamic linker creates the process image for an
  executable file or adds a shared object to the process image, it
  reads the relocation table and performs the associated actions. If
  this element is present, the dynamic structure must also have
  DT_RELASZ and DT_RELAENT elements. When relocation is ``mandatory''
  for a file, either DT_RELA or DT_REL may occur (both are permitted
  but not required).

* DT_RELASZ

  This element holds the total size, in bytes, of the DT_RELA
  relocation table.

* DT_RELAENT

  This element holds the size, in bytes, of the DT_RELA relocation
  entry.

* DT_STRSZ

  This element holds the size, in bytes, of the string table.

* DT_SYMENT

  This element holds the size, in bytes, of a symbol table entry.

* DT_INIT

  This element holds the address of the initialization function,
  discussed in ``Initialization and Termination Functions'' below.

* DT_FINI

  This element holds the address of the termination function,
  discussed in ``Initialization and Termination Functions'' below.

* DT_SONAME

  This element holds the string table offset of a null-terminated
  string, giving the name of the shared object. The offset is an index
  into the table recorded in the DT_STRTAB entry. See ``Shared Object
  Dependencies'' below for more information about these names.

* DT_RPATH

  This element holds the string table offset of a null-terminated
  search library search path string, discussed in ``Shared Object
  Dependencies.'' The offset is an index into the table recorded in
  the DT_STRTAB entry.

* DT_SYMBOLIC

  This element's presence in a shared object library alters the
  dynamic linker's symbol resolution algorithm for references within
  the library. Instead of starting a symbol search with the executable
  file, the dynamic linker starts from the shared object itself. If
  the shared object fails to supply the referenced symbol, the dynamic
  linker then searches the executable file and other shared objects as
  usual.

* DT_REL

  This element is similar to DT_RELA, except its table has implicit
  addends, such as Elf32_Rel for the 32-bit file class. If this
  element is present, the dynamic structure must also have DT_RELSZ
  and DT_RELENT elements.

* DT_RELSZ

  This element holds the total size, in bytes, of the DT_REL
  relocation table.

* DT_RELENT

  This element holds the size, in bytes, of the DT_REL relocation
  entry.

* DT_PLTREL

  This member specifies the type of relocation entry to which the
  procedure linkage table refers. The d_val member holds DT_REL or
  DT_RELA, as appropriate. All relocations in a procedure linkage
  table must use the same relocation.

* DT_DEBUG

  This member is used for debugging. Its contents are not specified
  for the ABI; programs that access this entry are not ABI-conforming.

* DT_TEXTREL

  This member's absence signifies that no relocation entry should
  cause a modification to a non-writable segment, as specified by the
  segment permissions in the program header table. If this member is
  present, one or more relocation entries might request modifications
  to a non-writable segment, and the dynamic linker can prepare
  accordingly.

* DT_JMPREL

  If present, this entries's d_ptr member holds the address of
  relocation entries associated solely with the procedure linkage
  table. Separating these relocation entries lets the dynamic linker
  ignore them during process initialization, if lazy binding is
  enabled. If this entry is present, the related entries of types
  DT_PLTRELSZ and DT_PLTREL must also be present.

* DT_LOPROC through DT_HIPROC

  Values in this inclusive range are reserved for processor-specific
  semantics.

Except for the DT_NULL element at the end of the array, and the
relative order of DT_NEEDED elements, entries may appear in any order.
Tag values not appearing in the table are reserved.


		      Shared Object Dependencies

When the link editor processes an archive library, it extracts library
members and copies them into the output object file. These statically
linked services are available during execution without involving the
dynamic linker. Shared objects also provide services, and the dynamic
linker must attach the proper shared object files to the process image
for execution. Thus executable and shared object files describe their
specific dependencies.

When the dynamic linker creates the memory segments for an object
file, the dependencies (recorded in DT_NEEDED entries of the dynamic
structure) tell what shared objects are needed to supply the program's
services. By repeatedly connecting referenced shared objects and their
dependencies, the dynamic linker builds a complete process image. When
resolving symbolic references, the dynamic linker examines the symbol
tables with a breadth-first search. That is, it first looks at the
symbol table of the executable program itself, then at the symbol
tables of the DT_NEEDED entries (in order), then at the second level
DT_NEEDED entries, and so on. Shared object files must be readable by
the process; other permissions are not required.

NOTE: Even when a shared object is referenced multiple times in the
dependency list, the dynamic linker will connect the object only once
to the process.

Names in the dependency list are copies either of the DT_SONAME
strings or the path names of the shared objects used to build the
object file. For example, if the link editor builds an executable file
using one shared object with a DT_SONAME entry of lib1 and another
shared object library with the path name /usr/lib/lib2, the executable
file will contain lib1 and /usr/lib/lib2 in its dependency list.

If a shared object name has one or more slash (/) characters anywhere
in the name, such as /usr/lib/lib2 above or directory/file, the
dynamic linker uses that string directly as the path name. If the name
has no slashes, such as lib1 above, three facilities specify shared
object path searching, with the following precedence.

* First, the dynamic array tag DT_RPATH may give a string that holds a
  list of directories, separated by colons (:). For example, the
  string /home/dir/lib:/home/dir2/lib: tells the dynamic linker to
  search first the directory /home/dir/lib, then /home/dir2/lib, and
  then the current directory to find dependencies.
* Second, a variable called LD_LIBRARY_PATH in the process environment
  [see exec(BA_OS)] may hold a list of directories as above,
  optionally followed by a semicolon (;) and another directory list.
  The following values would be equivalent to the previous example:
    LD_LIBRARY_PATH=/home/dir/lib:/home/dir2/lib:
    LD_LIBRARY_PATH=/home/dir/lib;/home/dir2/lib:
    LD_LIBRARY_PATH=/home/dir/lib:/home/dir2/lib:;
  All LD_LIBRARY_PATH directories are searched after those from
  DT_RPATH. Although some programs (such as the link editor) treat the
  lists before and after the semicolon differently, the dynamic linker
  does not. Nevertheless, the dynamic linker accepts the semicolon
  notation, with the semantics described above.
* Finally, if the other two groups of directories fail to locate the
  desired library, the dynamic linker searches /usr/lib.

NOTE: For security, the dynamic linker ignores environmental search
specifications (such as LD_LIBRARY_PATH) for set-user and set-group ID
programs. It does, however, search DT_RPATH directories and /usr/lib.


			 Global Offset Table

Position-independent code cannot, in general, contain absolute virtual
addresses. Global offset tables hold absolute addresses in private
data, thus making the addresses available without compromising the
position-independence and sharability of a program's text. A program
references its global offset table using position-independent
addressing and extracts absolute values, thus redirecting
position-independent references to absolute locations.

Initially, the global offset table holds information as required by
its relocation entries [see ``Relocation'' in Part 1]. After the
system creates memory segments for a loadable object file, the dynamic
linker processes the relocation entries, some of which will be type
R_386_GLOB_DAT referring to the global offset table. The dynamic
linker determines the associated symbol values, calculates their
absolute addresses, and sets the appropriate memory table entries to
the proper values. Although the absolute addresses are unknown when
the link editor builds an object file, the dynamic linker knows the
addresses of all memory segments and can thus calculate the absolute
addresses of the symbols contained therein.

If a program requires direct access to the absolute address of a
symbol, that symbol will have a global offset table entry. Because the
executable file and shared objects have separate global offset tables,
a symbol's address may appear in several tables. The dynamic linker
processes all the global offset table relocations before giving
control to any code in the process image, thus ensuring the absolute
addresses are available during execution.

The table's entry zero is reserved to hold the address of the dynamic
structure, referenced with the symbol _DYNAMIC. This allows a program,
such as the dynamic linker, to find its own dynamic structure without
having yet processed its relocation entries. This is especially
important for the dynamic linker, because it must initialize itself
without relying on other programs to relocate its memory image. On the
32-bit Intel Architecture, entries one and two in the global offset
table also are reserved. ``Procedure Linkage Table'' below describes
them.

The system may choose different memory segment addresses for the same
shared object in different programs; it may even choose different
library addresses for different executions of the same program.
Nonetheless, memory segments do not change addresses once the process
image is established. As long as a process exists, its memory segments
reside at fixed virtual addresses.

A global offset table's format and interpretation are
processor-specific. For the 32-bit Intel Architecture, the symbol
_GLOBAL_OFFSET_TABLE_ may be used to access the table.

+ Figure 2-11: Global Offset Table

  extern Elf32_Addr _GLOBAL_OFFSET_TABLE_[];

The symbol _GLOBAL_OFFSET_TABLE_ may reside in the middle of the .got
section, allowing both negative and non-negative ``subscripts'' into
the array of addresses.


		       Procedure Linkage Table

Much as the global offset table redirects position-independent address
calculations to absolute locations, the procedure linkage table
redirects position-independent function calls to absolute locations.
The link editor cannot resolve execution transfers (such as function
calls) from one executable or shared object to another. Consequently,
the link editor arranges to have the program transfer control to
entries in the procedure linkage table. On the SYSTEM V architecture,
procedure linkage tables reside in shared text, but they use addresses
in the private global offset table. The dynamic linker determines the
destinations' absolute addresses and modifies the global offset
table's memory image accordingly. The dynamic linker thus can redirect
the entries without compromising the position-independence and
sharability of the program's text. Executable files and shared object
files have separate procedure linkage tables.

+ Figure 2-12: Absolute Procedure Linkage Table {*}

  .PLT0:pushl   got_plus_4
        jmp     *got_plus_8
        nop; nop
        nop; nop
  .PLT1:jmp     *name1_in_GOT
        pushl   $offset
        jmp     .PLT0@PC
  .PLT2:jmp     *name2_in_GOT
        pushl   $offset
        jmp     .PLT0@PC
        ...

+ Figure 2-13: Position-Independent Procedure Linkage Table

  .PLT0:pushl   4(%ebx)
        jmp     *8(%ebx)
        nop; nop
        nop; nop
  .PLT1:jmp     *name1@GOT(%ebx)
        pushl   $offset
        jmp     .PLT0@PC
  .PLT2:jmp     *name2@GOT(%ebx)
        pushl   $offset
        jmp     .PLT0@PC
        ...

NOTE: As the figures show, the procedure linkage table instructions
use different operand addressing modes for absolute code and for
position-independent code. Nonetheless, their interfaces to the
dynamic linker are the same.

Following the steps below, the dynamic linker and the program
``cooperate'' to resolve symbolic references through the procedure
linkage table and the global offset table.

1. When first creating the memory image of the program, the dynamic
   linker sets the second and the third entries in the global offset
   table to special values. Steps below explain more about these
   values.
2. If the procedure linkage table is position-independent, the address
   of the global offset table must reside in %ebx. Each shared object
   file in the process image has its own procedure linkage table, and
   control transfers to a procedure linkage table entry only from
   within the same object file. Consequently, the calling function is
   responsible for setting the global offset table base register
   before calling the procedure linkage table entry.
3. For illustration, assume the program calls name1, which transfers
   control to the label .PLT1.
4. The first instruction jumps to the address in the global offset
   table entry for name1. Initially, the global offset table holds the
   address of the following pushl instruction, not the real address of
   name1.
5. Consequently, the program pushes a relocation offset (offset) on
   the stack. The relocation offset is a 32-bit, non-negative byte
   offset into the relocation table. The designated relocation entry
   will have type R_386_JMP_SLOT, and its offset will specify the
   global offset table entry used in the previous jmp instruction. The
   relocation entry also contains a symbol table index, thus telling
   the dynamic linker what symbol is being referenced, name1 in this
   case.
6. After pushing the relocation offset, the program then jumps to
   .PLT0, the first entry in the procedure linkage table. The pushl
   instruction places the value of the second global offset table
   entry (got_plus_4 or 4(%ebx)) on the stack, thus giving the dynamic
   linker one word of identifying information. The program then jumps
   to the address in the third global offset table entry (got_plus_8
   or 8(%ebx)), which transfers control to the dynamic linker.
7. When the dynamic linker receives control, it unwinds the stack,
   looks at the designated relocation entry, finds the symbol's value,
   stores the ``real'' address for name1 in its global offset table
   entry, and transfers control to the desired destination.
8. Subsequent executions of the procedure linkage table entry will
   transfer directly to name1, without calling the dynamic linker a
   second time. That is, the jmp instruction at .PLT1 will transfer to
   name1, instead of ``falling through'' to the pushl instruction.

The LD_BIND_NOW environment variable can change dynamic linking
behavior. If its value is non-null, the dynamic linker evaluates
procedure linkage table entries before transferring control to the
program. That is, the dynamic linker processes relocation entries of
type R_386_JMP_SLOT during process initialization. Otherwise, the
dynamic linker evaluates procedure linkage table entries lazily,
delaying symbol resolution and relocation until the first execution of
a table entry.

NOTE: Lazy binding generally improves overall application performance,
because unused symbols do not incur the dynamic linking overhead.
Nevertheless, two situations make lazy binding undesirable for some
applications. First, the initial reference to a shared object function
takes longer than subsequent calls, because the dynamic linker
intercepts the call to resolve the symbol. Some applications cannot
tolerate this unpredictability. Second, if an error occurs and the
dynamic linker cannot resolve the symbol, the dynamic linker will
terminate the program. Under lazy binding, this might occur at
arbitrary times. Once again, some applications cannot tolerate this
unpredictability. By turning off lazy binding, the dynamic linker
forces the failure to occur during process initialization, before the
application receives control.


			      Hash Table

A hash table of Elf32_Word objects supports symbol table access.
Labels appear below to help explain the hash table organization, but
they are not part of the specification.

+ Figure 2-14: Symbol Hash Table

  nbucket
  nchain
  bucket[0]
  ...
  bucket[nbucket - 1]
  chain[0]
  ...
  chain[nchain - 1]

The bucket array contains nbucket entries, and the chain array
contains nchain entries; indexes start at 0. Both bucket and chain
hold symbol table indexes. Chain table entries parallel the symbol
table. The number of symbol table entries should equal nchain; so
symbol table indexes also select chain table entries. A hashing
function (shown below) accepts a symbol name and returns a value that
may be used to compute a bucket index. Consequently, if the hashing
function returns the value x for some name, bucket[x%nbucket] gives an
index, y, into both the symbol table and the chain table. If the
symbol table entry is not the one desired, chain[y] gives the next
symbol table entry with the same hash value. One can follow the chain
links until either the selected symbol table entry holds the desired
name or the chain entry contains the value STN_UNDEF.

+ Figure 2-15: Hashing Function

  unsigned long
  elf_hash(const unsigned char *name)
  {
      unsigned long       h = 0, g;
  
      while (*name) {
          h = (h << 4) + *name++;
          if (g = h & 0xf0000000)
              h ^= g >> 24;
          h &= ~g;
      }
      return h;
  }


	       Initialization and Termination Functions

After the dynamic linker has built the process image and performed the
relocations, each shared object gets the opportunity to execute some
initialization code. These initialization functions are called in no
specified order, but all shared object initializations happen before
the executable file gains control.

Similarly, shared objects may have termination functions, which are
executed with the atexit(BA_OS) mechanism after the base process
begins its termination sequence. Once again, the order in which the
dynamic linker calls termination functions is unspecified.

Shared objects designate their initialization and termination
functions through the DT_INIT and DT_FINI entries in the dynamic
structure, described in ``Dynamic Section'' above. Typically, the code
for these functions resides in the .init and .fini sections, mentioned
in ``Sections'' of Part 1.

NOTE: Although the atexit(BA_OS) termination processing normally will
be done, it is not guaranteed to have executed upon process death. In
particular, the process will not execute the termination processing if
it calls _exit [see exit(BA_OS)] or if the process dies because it
received a signal that it neither caught nor ignored.

   ________________________________________________________________


			     3. C LIBRARY

   ________________________________________________________________


   ========================== C Library ===========================


The C library, libc, contains all of the symbols contained in libsys,
and, in addition, contains the routines listed in the following two
tables. The first table lists routines from the ANSI C standard.

+ Figure 3-1: libc Contents, Names without Synonyms

  abort        fputc        isprint      putc         strncmp
  abs	       fputs        ispunct      putchar      strncpy
  asctime      fread        isspace      puts         strpbrk
  atof	       freopen      isupper      qsort        strrchr
  atoi	       frexp        isxdigit     raise        strspn
  atol	       fscanf       labs         rand         strstr
  bsearch      fseek        ldexp        rewind       strtod
  clearerr     fsetpos      ldiv         scanf        strtok
  clock	       ftell        localtime    setbuf       strtol
  ctime	       fwrite       longjmp      setjmp       strtoul
  difftime     getc         mblen        setvbuf      tmpfile
  div	       getchar      mbstowcs     sprintf      tmpnam
  fclose       getenv       mbtowc       srand        tolower
  feof	       gets         memchr       sscanf       toupper
  ferror       gmtime       memcmp       strcat       ungetc
  fflush       isalnum      memcpy       strchr       vfprintf
  fgetc	       isalpha      memmove      strcmp       vprintf
  fgetpos      iscntrl      memset       strcpy       vsprintf
  fgets	       isdigit      mktime       strcspn      wcstombs
  fopen	       isgraph      perror       strlen       wctomb
  fprintf      islower      printf       strncat    

Additionally, libc holds the following services.

+ Figure 3-2: libc Contents, Names with Synonyms

  __assert     getdate      lockf **     sleep        tell ** 
  cfgetispeed  getopt       lsearch      strdup       tempnam
  cfgetospeed  getpass      memccpy      swab         tfind
  cfsetispeed  getsubopt    mkfifo       tcdrain      toascii
  cfsetospeed  getw         mktemp       tcflow       _tolower
  ctermid      hcreate      monitor      tcflush      tsearch
  cuserid      hdestroy     nftw         tcgetattr    _toupper
  dup2	       hsearch      nl_langinfo  tcgetpgrp    twalk
  fdopen       isascii      pclose       tcgetsid     tzset
  __filbuf     isatty       popen        tcsendbreak  _xftw
  fileno       isnan        putenv       tcsetattr    
  __flsbuf     isnand **    putw         tcsetpgrp    
  fmtmsg **    lfind        setlabel     tdelete      

  ** = Function is at Level 2 in the SVID Issue 3 and therefore at
       Level 2 in the ABI.

Besides the symbols listed in the With Synonyms table above, synonyms
of the form _<name> exist for <name> entries that are not listed with
a leading underscore prepended to their name. Thus libc contains both
getopt and _getopt, for example.

Of the routines listed above, the following are not defined elsewhere.

int __filbuf(FILE *f);
	This function returns the next input character for f, filling
	its buffer as appropriate. It returns EOF if an error occurs.

int __flsbuf(int x, FILE *f);
	This function flushes the output characters for f as if
	putc(x, f) had been called and then appends the value of x to
	the resulting output stream. It returns EOF if an error occurs
	and x otherwise.

int _xftw(int, char *, int (*)(char *, struct stat *, int), int);
	Calls to the ftw(BA_LIB) function are mapped to this function
	when applications are compiled. This function is identical to
	ftw(BA_LIB), except that _xftw() takes an interposed first
	argument, which must have the value 2.

See this chapter's other library sections for more SVID, ANSI C, and
POSIX facilities. See ``System Data Interfaces'' later in this chapter
for more information.


			 Global Data Symbols

The libc library requires that some global external data symbols be
defined for its routines to work properly. All the data symbols
required for the libsys library must be provided by libc, as well as
the data symbols listed in the table below.

For formal declarations of the data objects represented by these
symbols, see the System V Interface Definition, Third Edition or the
``Data Definitions'' section of Chapter 6 in the appropriate processor
supplement to the System V ABI.

For entries in the following table that are in <name>-_<name> form,
both symbols in each pair represent the same data. The underscore
synonyms are provided to satisfy the ANSI C standard.

+ Figure 3-3: libc Contents, Global External Data Symbols

  getdate_err		optarg
  _getdate_err		opterr
  __iob			optind
			optopt



section -- 节
section name -- 节名
section header 
section header table -- 节头表
section header table entry -- 节头表表项
section header table index -- 节头表索引
section header string talbe -- 节名字符串表 （节名表）

program segment -- 程序段
program segment table -- 程序头表
program segment table entry -- 程序头表表项


symbol table -- 符号表
symbol table entry -- 符号表项
symbol table index -- 符号表索引

string table -- 字符串表
string table section -- 字符串表节
string table index -- 字符串表索引

procedure linkage table -- 程序连接表

common block -- 公用块
escape value -- 溢出值：在实验研究分析或运行数据统计时，个别数据可能有与其它数据偏离较远的现象，这些数据叫做可疑值或叫逸出值。

